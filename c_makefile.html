<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Makefile's Notes</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="title" content="Makefile's Notes"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2012-04-11 Wed"/>
<meta name="author" content="Joseph Pan"/>
<meta name="description" content="C/C++笔记"/>
<meta name="keywords" content="C, C++"/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style><link rel="stylesheet" href="./other/style.css" type="text/css"/>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>
<div id="org-div-home-and-up" style="text-align:right;font-size:70%;white-space:nowrap;">
 <a accesskey="h" href="./c_index.html"> UP </a>
 |
 <a accesskey="H" href="./index.html"> HOME </a>
</div>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">Makefile's Notes</h1>




<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 内容来源</a></li>
<li><a href="#sec-2">2 概述</a>
<ul>
<li><a href="#sec-2-1">2.1 关于程序的编译和链接</a></li>
</ul>
</li>
<li><a href="#sec-3">3 Makefile 介绍</a>
<ul>
<li><a href="#sec-3-1">3.1 规则</a></li>
<li><a href="#sec-3-2">3.2 一个示例</a></li>
<li><a href="#sec-3-3">3.3 make是如何工作的</a></li>
<li><a href="#sec-3-4">3.4 makefile中使用变量</a></li>
<li><a href="#sec-3-5">3.5 让make自动推导</a></li>
<li><a href="#sec-3-6">3.6 另类风格的makefile</a></li>
<li><a href="#sec-3-7">3.7 清空目标文件的规则</a></li>
<li><a href="#sec-3-8">3.8 Makefile里有什么？</a></li>
<li><a href="#sec-3-9">3.9 Makefile的文件名</a></li>
<li><a href="#sec-3-10">3.10 引用其它的Makefile</a></li>
<li><a href="#sec-3-11">3.11 环境变量 MAKEFILES</a></li>
<li><a href="#sec-3-12">3.12 make的工作方式</a></li>
</ul>
</li>
<li><a href="#sec-4">4 书写规则</a>
<ul>
<li><a href="#sec-4-1">4.1 规则举例</a></li>
<li><a href="#sec-4-2">4.2 规则的语法</a></li>
<li><a href="#sec-4-3">4.3 在规则中使用通配符</a></li>
<li><a href="#sec-4-4">4.4 文件搜寻</a></li>
<li><a href="#sec-4-5">4.5 伪目标</a></li>
<li><a href="#sec-4-6">4.6 多目标</a></li>
<li><a href="#sec-4-7">4.7 静态模式</a></li>
<li><a href="#sec-4-8">4.8 自动生成依赖性</a></li>
</ul>
</li>
<li><a href="#sec-5">5 书写命令</a>
<ul>
<li><a href="#sec-5-1">5.1 显示命令</a></li>
<li><a href="#sec-5-2">5.2 命令执行</a></li>
<li><a href="#sec-5-3">5.3 命令出错</a></li>
<li><a href="#sec-5-4">5.4 嵌套执行 make</a>
<ul>
<li><a href="#sec-5-4-1">5.4.1 参数传递</a></li>
</ul>
</li>
<li><a href="#sec-5-5">5.5 定义命令包</a></li>
</ul>
</li>
<li><a href="#sec-6">6 使用变量</a>
<ul>
<li><a href="#sec-6-1">6.1 变量的基础</a></li>
<li><a href="#sec-6-2">6.2 变量中的变量</a></li>
<li><a href="#sec-6-3">6.3 变量高级用法</a>
<ul>
<li><a href="#sec-6-3-1">6.3.1 变量值的替换</a></li>
<li><a href="#sec-6-3-2">6.3.2 把变量的值再当成变量</a></li>
</ul>
</li>
<li><a href="#sec-6-4">6.4 追加变量值</a></li>
<li><a href="#sec-6-5">6.5 override 指示符</a></li>
<li><a href="#sec-6-6">6.6 多行变量</a></li>
<li><a href="#sec-6-7">6.7 环境变量</a></li>
<li><a href="#sec-6-8">6.8 目标变量</a></li>
<li><a href="#sec-6-9">6.9 模式变量</a></li>
</ul>
</li>
<li><a href="#sec-7">7 使用条件判断</a>
<ul>
<li><a href="#sec-7-1">7.1 示例</a></li>
<li><a href="#sec-7-2">7.2 语法</a></li>
</ul>
</li>
<li><a href="#sec-8">8 使用 函数</a>
<ul>
<li><a href="#sec-8-1">8.1 函数的调用语法</a></li>
<li><a href="#sec-8-2">8.2 字符串处理函数</a>
<ul>
<li><a href="#sec-8-2-1">8.2.1 subst</a></li>
<li><a href="#sec-8-2-2">8.2.2 patsubst</a></li>
<li><a href="#sec-8-2-3">8.2.3 strip</a></li>
<li><a href="#sec-8-2-4">8.2.4 findstring</a></li>
<li><a href="#sec-8-2-5">8.2.5 filter</a></li>
<li><a href="#sec-8-2-6">8.2.6 filter-out</a></li>
<li><a href="#sec-8-2-7">8.2.7 sort</a></li>
<li><a href="#sec-8-2-8">8.2.8 word</a></li>
<li><a href="#sec-8-2-9">8.2.9 wordlist</a></li>
<li><a href="#sec-8-2-10">8.2.10 words</a></li>
<li><a href="#sec-8-2-11">8.2.11 firstword</a></li>
<li><a href="#sec-8-2-12">8.2.12 字符串函数实例</a></li>
</ul>
</li>
<li><a href="#sec-8-3">8.3 文件名操作函数</a>
<ul>
<li><a href="#sec-8-3-1">8.3.1 dir</a></li>
<li><a href="#sec-8-3-2">8.3.2 notdir</a></li>
<li><a href="#sec-8-3-3">8.3.3 suffix</a></li>
<li><a href="#sec-8-3-4">8.3.4 basename</a></li>
<li><a href="#sec-8-3-5">8.3.5 addsuffix</a></li>
<li><a href="#sec-8-3-6">8.3.6 addprefix</a></li>
<li><a href="#sec-8-3-7">8.3.7 join</a></li>
</ul>
</li>
<li><a href="#sec-8-4">8.4 foreach函数</a></li>
<li><a href="#sec-8-5">8.5 if函数</a></li>
<li><a href="#sec-8-6">8.6 call函数</a></li>
<li><a href="#sec-8-7">8.7 origin 函数</a></li>
<li><a href="#sec-8-8">8.8 shell函数</a></li>
<li><a href="#sec-8-9">8.9 控制make的函数</a>
<ul>
<li><a href="#sec-8-9-1">8.9.1 error</a></li>
<li><a href="#sec-8-9-2">8.9.2 warning</a></li>
</ul></li>
</ul>
</li>
<li><a href="#sec-9">9 make 的运行</a>
<ul>
<li><a href="#sec-9-1">9.1 make 的退出码</a></li>
<li><a href="#sec-9-2">9.2 指定 makefile</a></li>
<li><a href="#sec-9-3">9.3 指定目标</a></li>
<li><a href="#sec-9-4">9.4 检查规则</a></li>
<li><a href="#sec-9-5">9.5 make 的参数</a></li>
</ul>
</li>
<li><a href="#sec-10">10 隐含规则</a>
<ul>
<li><a href="#sec-10-1">10.1 使用隐含规则</a></li>
<li><a href="#sec-10-2">10.2 隐含规则一览</a>
<ul>
<li><a href="#sec-10-2-1">10.2.1 编译 C 程序的隐含规则</a></li>
<li><a href="#sec-10-2-2">10.2.2 编译 C++程序的隐含规则</a></li>
<li><a href="#sec-10-2-3">10.2.3 编译 Pascal 程序的隐含规则</a></li>
<li><a href="#sec-10-2-4">10.2.4 编译 Fortran/Ratfor 程序的隐含规则</a></li>
<li><a href="#sec-10-2-5">10.2.5 预处理 Fortran/Ratfor 程序的隐含规则</a></li>
<li><a href="#sec-10-2-6">10.2.6 编译 Modula-2 程序的隐含规则</a></li>
<li><a href="#sec-10-2-7">10.2.7 汇编和汇编预处理的隐含规则</a></li>
<li><a href="#sec-10-2-8">10.2.8 链接 Object 文件的隐含规则</a></li>
<li><a href="#sec-10-2-9">10.2.9 Yacc C 程序时的隐含规则</a></li>
<li><a href="#sec-10-2-10">10.2.10 Lex C 程序时的隐含规则</a></li>
<li><a href="#sec-10-2-11">10.2.11 Lex Ratfor 程序时的隐含规则</a></li>
<li><a href="#sec-10-2-12">10.2.12 从 C 程序、Yacc 文件或 Lex 文件创建 Lint 库的隐含规则</a></li>
</ul>
</li>
<li><a href="#sec-10-3">10.3 隐含规则使用的变量</a>
<ul>
<li><a href="#sec-10-3-1">10.3.1 关于命令的变量</a></li>
<li><a href="#sec-10-3-2">10.3.2 关于命令参数的变量</a></li>
</ul>
</li>
<li><a href="#sec-10-4">10.4 隐含规则链</a></li>
<li><a href="#sec-10-5">10.5 定义模式规则</a>
<ul>
<li><a href="#sec-10-5-1">10.5.1 模式规则介绍</a></li>
<li><a href="#sec-10-5-2">10.5.2 模式规则示例</a></li>
<li><a href="#sec-10-5-3">10.5.3 自动化变量</a></li>
</ul>
</li>
<li><a href="#sec-10-6">10.6 模式的匹配</a></li>
<li><a href="#sec-10-7">10.7 重载内建隐含规则</a></li>
<li><a href="#sec-10-8">10.8 老式风格的"后缀规则"</a></li>
<li><a href="#sec-10-9">10.9 隐含规则搜索算法</a></li>
</ul>
</li>
<li><a href="#sec-11">11 使用 make 更新函数库文件</a>
<ul>
<li><a href="#sec-11-1">11.1 函数库文件的成员</a></li>
<li><a href="#sec-11-2">11.2 函数库成员的隐含规则</a></li>
<li><a href="#sec-11-3">11.3 函数库文件的后缀规则</a></li>
<li><a href="#sec-11-4">11.4 注意事项</a></li>
</ul>
</li>
<li><a href="#sec-12">12 后序</a></li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 内容来源</h2>
<div class="outline-text-2" id="text-1">


<ul>
<li>陈皓 <a href="http://wiki.ubuntu.org.cn/跟我一起写Makefile">跟我一起写Makefile</a> 
</li>
</ul>


</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 概述</h2>
<div class="outline-text-2" id="text-2">


<p>
  会不会写 makefile，从一个侧面说明了一个人是否具备完成大型工程的能力。 因为，makefile 关系到了整个工程的编译规则。一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile 定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为makefile 就像一个 Shell 脚本一样，其中也可以执行操作系统的命令。 makefile 带来的好处就是 ——“自动化编译”，一旦写好，只需要一个 make 命令，整个工程完全自动编译，极大的提高了软件开发的效率。make 是一个命令工具，是一个解释 makefile 中指令的命令工具，一般来说，大多数的 IDE 都有这个命令，比如:Delphi 的 make，Visual C++的 nmake， Linux 下 GNU 的make。可见， makefile 都成为了一种在工程方面的编译方法。
</p>

</div>

<div id="outline-container-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 关于程序的编译和链接</h3>
<div class="outline-text-3" id="text-2-1">


<p>
  源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。在编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成 Object File。而在链接程序时，链接器会在所有的 Object File 中找寻函数的实现，如果找不到，那到就会报链接错误码(Linker Error) ，在 VC 下，这种错误一般是:Link 2001 错误，意思说是说，链接器未能找到函数的实现。你需要指定函数的Object File。
</p>
</div>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Makefile 介绍</h2>
<div class="outline-text-2" id="text-3">


<p>
  make 命令执行时，需要一个 Makefile 文件，以告诉 make 命令需要怎么样的去编译和链接程序。我们的规则是：
</p>
<ol>
<li>如果这个工程没有编译过，那么我们的所有 C 文件都要编译并被链接。
</li>
<li>如果这个工程的某几个 C 文件被修改，那么我们只编译被修改的 C 文件，并链接目标程序。
</li>
<li>如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的 C 文件，并链接目标程序。
</li>
</ol>


<p>
只要我们的 Makefile 写得够好，所有的这一切，我们只用一个 make 命令就可以完成， make 命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自己编译所需要的文件和链接目标程序。
</p>

</div>

<div id="outline-container-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> 规则</h3>
<div class="outline-text-3" id="text-3-1">


<p>
在讲述这个 Makefile 之前，还是让我们先来粗略地看一看 Makefile 的规则。
</p>



<pre class="example">target ... : prerequisites ...
        command
        ...
        ...
</pre>


<ul>
<li>target ： 一个目标文件， <b>可以是 Object File，也可以是执行文件。还可以是一个标签  (Label)</b> (例如clean) 。
</li>
<li>prerequisites ： 要生成那个 target 所需要的文件或是目标。
</li>
<li>command ： make 需要执行的命令(任意的 Shell 命令)。
</li>
</ul>


</div>

</div>

<div id="outline-container-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> 一个示例</h3>
<div class="outline-text-3" id="text-3-2">


<p>
   正如前面所说的，如果一个工程有 3 个头文件，和 8 个 C 文件，我们为了完成前面所述的
那三个规则，我们的 Makefile 应该是下面的这个样子的。
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">edit</span> : main.o kbd.o command.o display.o \
                insert.o search.o files.o utils.o
        cc -o edit main.o kbd.o command.o display.o \
                insert.o search.o files.o utils.o

<span style="color: #ffd700; font-weight: bold;">main.o</span> : main.c defs.h
        cc -c main.c
<span style="color: #ffd700; font-weight: bold;">kbd.o</span> : kbd.c defs.h command.h
        cc -c kbd.c
<span style="color: #ffd700; font-weight: bold;">command.o</span> : command.c defs.h command.h
        cc -c command.c
<span style="color: #ffd700; font-weight: bold;">display.o</span> : display.c defs.h buffer.h
        cc -c display.c
<span style="color: #ffd700; font-weight: bold;">insert.o</span> : insert.c defs.h buffer.h
        cc -c insert.c
<span style="color: #ffd700; font-weight: bold;">search.o</span> : search.c defs.h buffer.h
        cc -c search.c
<span style="color: #ffd700; font-weight: bold;">files.o</span> : files.c defs.h buffer.h command.h
        cc -c files.c
<span style="color: #ffd700; font-weight: bold;">utils.o</span> : utils.c defs.h
        cc -c utils.c
<span style="color: #ffd700; font-weight: bold;">clean</span> :
        rm edit main.o kbd.o command.o display.o \
                insert.o search.o files.o utils.o
</pre>


<p>
<code>make</code> : 反斜杠(\)是换行符的意思。这样比较便于 Makefile 的易读。我们可以把这个内容保存在文 件为“Makefile”或“makefile”的文件中，然后在该目录下直接输入命令 <b>“make”</b> 就
 可以生成执行文件 edit。
</p>
<p>
<code>make clean</code> : 如果要删除执行文件和所有的中间目标文件，那么，只要简单地执行一下 <b>“make clean”</b> 就可以了。clean 不是一个文件，它只不过是一个动作名字，有点像 C 语言中的lable 一样，其冒号后什么也没有，那么，make 就不会自动去找文件的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在 make 命令后明显得指出这个lable 的名字。这样的方法非常有用，我们可以在一个 makefile 中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。(详见 <a href="#sec-4-5">伪目标</a> )
</p>

<p>
目标文件(target)包含：
</p><ol>
<li>执行文件 edit;
</li>
<li>中间目标文件(.o);
</li>
<li>依赖文件(prerequisites)， 就是冒号后面的那些 .c 文件和 .h 文件。每一个 .o 文件都有一组依赖文件，而这些 .o 文件又是执行文件 edit 的依赖文件。依赖关系的实质上就是说明了目标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的。
</li>
</ol>


<p>
后续的那一行定义了如何生成目标文件的操作系统命令， <b>一定要以一个 Tab 键作为开头</b> 。记住， <b>make 并不管命令是怎么工作的，他只管执行所定义的命令</b> 。make 会比较 targets 文件和 prerequisites 文件的修改日期，如果 prerequisites 文件的日期要比 targets 文件的日期要新，或者 target 不存在的话，那么，make 就会执行后续定义的命令。
</p>
</div>

</div>

<div id="outline-container-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> make是如何工作的</h3>
<div class="outline-text-3" id="text-3-3">


<p>
   在默认的方式下，也就是我们只输入 make 命令。那么，
</p><ol>
<li>make 会在当前目录下找名字叫“Makefile”或“makefile”的文件。
</li>
<li>如果找到，它会找文件中的第一个目标文件(target)，在上面的例子中，他会找到“edit”这个文件，并把这个文件作为最终的目标文件。
</li>
<li>如果 edit 文件不存在，或是 edit 所依赖的后面的 .o 文件的文件修改时间要比 edit 这个文件新，那么，他就会执行后面所定义的命令来生成 edit 这个文件。
</li>
<li>如果 edit 所依赖的.o 文件也存在，那么 make 会在当前文件中找目标为.o 文件的依赖性，如果找到则再根据那一个规则生成.o 文件。(这有点像一个堆栈的过程)
</li>
<li>当然，你的 C 文件和 H 文件是存在的啦，于是 make 会生成 .o 文件，然后再用 .o 文件生命 make 的终极任务，也就是执行文件 edit 了。
</li>
</ol>


<p>
这就是整个 make 的依赖性，make 会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make 就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make 根本不理。make 只管文件的依赖性，即，如果在我找了依赖关系之后，冒号后面的文件还是不在，那么对不起，我就不工作啦。
</p>
<p>
通过上述分析，我们知道，像 clean 这种，没有被第一个目标文件直接或间接关联，那么它后面
所定义的命令将不会被自动执行，不过，我们可以显示要 make 执行。即命令 <code>make clean</code> ，以此来清除所有的目标文件，以便重编译。
</p>
<p>
于是在我们编程中，如果这个工程已被编译过了，当我们修改了其中一个源文件，比如file.c，
那么根据我们的依赖性，我们的目标 file.o 会被重编译(也就是在这个依性关系后面所定义
的命令) ，于是 file.o 的文件也是最新的啦，于是 file.o 的文件修改时间要比 edit 要新，所
以 edit 也会被重新链接了(详见 edit 目标文件后定义的命令)。
</p>
<p>
而如果我们改变了“command.h”，那么， kdb.o、command.o 和 files.o 都会被重编译，并
且，edit 会被重链接。
</p>
</div>

</div>

<div id="outline-container-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> makefile中使用变量</h3>
<div class="outline-text-3" id="text-3-4">


<p>
   在上面的例子中,先让我们看看 edit 的规则:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">edit</span> : main.o kbd.o command.o display.o \
                insert.o search.o files.o utils.o
        cc -o edit main.o kbd.o command.o display.o \
                insert.o search.o files.o utils.o
</pre>


<p>
我们可以看到[.o]文件的字符串被重复了两次，如果我们的工程需要加入一个新的[.o]文件，
那么我们需要在两个地方加（应该是三个地方，还有一个地方在clean中）。当然，我们的
makefile并不复杂，所以在两个地方加也不累，但如果makefile变得复杂，那么我们就有可
能会忘掉一个需要加入的地方，而导致编译失败。所以，为了makefile的易维护，在
makefile中我们可以使用变量。makefile的变量也就是一个字符串，理解成C语言中的宏可能
会更好。
</p>
<p>
比如，我们声明一个变量，叫objects，OBJECTS，objs，OBJS，obj，或是 OBJ，反正不管什么啦，只要能够表示obj文件就行了。我们在makefile一开始就这样定义：
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">objects</span> = main.o kbd.o command.o display.o \
                insert.o search.o files.o utils.o
</pre>


<p>
于是，我们就可以很方便地在我们的makefile中以 <code>$(objects)</code> 的方式来使用这个变量了，于是我们的改良版makefile就变成下面这个样子：
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">objects</span> = main.o kbd.o command.o display.o \
                insert.o search.o files.o utils.o

<span style="color: #ffd700; font-weight: bold;">edit</span> : $(<span style="color: #ffd700; font-style: italic;">objects</span>)
        cc -o edit $(<span style="color: #ffd700; font-style: italic;">objects</span>)
<span style="color: #ffd700; font-weight: bold;">main.o</span> : main.c defs.h
        cc -c main.c
<span style="color: #ffd700; font-weight: bold;">kbd.o</span> : kbd.c defs.h command.h
        cc -c kbd.c
<span style="color: #ffd700; font-weight: bold;">command.o</span> : command.c defs.h command.h
        cc -c command.c
<span style="color: #ffd700; font-weight: bold;">display.o</span> : display.c defs.h buffer.h
        cc -c display.c
<span style="color: #ffd700; font-weight: bold;">insert.o</span> : insert.c defs.h buffer.h
        cc -c insert.c
<span style="color: #ffd700; font-weight: bold;">search.o</span> : search.c defs.h buffer.h
        cc -c search.c
<span style="color: #ffd700; font-weight: bold;">files.o</span> : files.c defs.h buffer.h command.h
        cc -c files.c
<span style="color: #ffd700; font-weight: bold;">utils.o</span> : utils.c defs.h
        cc -c utils.c
<span style="color: #ffd700; font-weight: bold;">clean</span> :
        rm edit $(<span style="color: #ffd700; font-style: italic;">objects</span>)
</pre>


<p>
于是如果有新的 .o 文件加入，我们只需简单地修改一下 objects 变量就可以了。
</p>
</div>

</div>

<div id="outline-container-3-5" class="outline-3">
<h3 id="sec-3-5"><span class="section-number-3">3.5</span> 让make自动推导</h3>
<div class="outline-text-3" id="text-3-5">


<p>
   GNU的make很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个[.o]文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。
</p>
<p>
   <b>只要make看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中</b> ，如果make找到一个whatever.o，那么 whatever.c，就会是whatever.o的依赖文件。并且 <code>cc -c whatever.c</code> 也会被推导出来，于是，我们的makefile 再也不用写得这么复杂。我们的新makefile又出炉了。
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">objects</span> = main.o kbd.o command.o display.o \
                insert.o search.o files.o utils.o
<span style="color: #ffd700; font-style: italic;">cc</span> = gcc

<span style="color: #ffd700; font-weight: bold;">edit</span> : $(<span style="color: #ffd700; font-style: italic;">objects</span>)
        cc -o edit $(<span style="color: #ffd700; font-style: italic;">objects</span>)

<span style="color: #ffd700; font-weight: bold;">main.o</span> : defs.h
<span style="color: #ffd700; font-weight: bold;">kbd.o</span> : defs.h command.h
<span style="color: #ffd700; font-weight: bold;">command.o</span> : defs.h command.h
<span style="color: #ffd700; font-weight: bold;">display.o</span> : defs.h buffer.h
<span style="color: #ffd700; font-weight: bold;">insert.o</span> : defs.h buffer.h
<span style="color: #ffd700; font-weight: bold;">search.o</span> : defs.h buffer.h
<span style="color: #ffd700; font-weight: bold;">files.o</span> : defs.h buffer.h command.h
<span style="color: #ffd700; font-weight: bold;">utils.o</span> : defs.h

<span style="color: #ffd700; font-weight: bold;">.PHONY</span> : clean
<span style="color: #ffd700; font-weight: bold;">clean</span> :
        rm edit $(<span style="color: #ffd700; font-style: italic;">objects</span>)   
</pre>


<p>
   这种方法，也就是make的 <b>“隐晦规则”</b> 。上面文件内容中， <code>.PHONY</code> 表示，clean是个 <a href="#sec-4-5">伪目标</a> 文件。
</p>
</div>

</div>

<div id="outline-container-3-6" class="outline-3">
<h3 id="sec-3-6"><span class="section-number-3">3.6</span> 另类风格的makefile</h3>
<div class="outline-text-3" id="text-3-6">


<p>
   既然我们的make可以自动推导命令，那么我看到那堆[.o]和[.h]的依赖就有点不爽，那么多的重复的[.h]，能不能把其收拢起来，好吧，没有问题，这个对于make来说很容易，谁叫它提供了自动推导命令和文件的功能呢？来看看最新风格的makefile吧。
</p>



<pre class="src src-sh">objects = main.o kbd.o command.o display.o <span style="color: #f0e68c;">\</span>
                insert.o search.o files.o utils.o

edit : $(<span style="color: #fa8072;">objects</span>)
        cc -o edit $(<span style="color: #fa8072;">objects</span>)

$(<span style="color: #fa8072;">objects</span>) : defs.h
kbd.o command.o files.o : command.h
display.o insert.o search.o files.o : buffer.h

.PHONY : clean
clean :
        rm edit $(<span style="color: #fa8072;">objects</span>)
</pre>


</div>

</div>

<div id="outline-container-3-7" class="outline-3">
<h3 id="sec-3-7"><span class="section-number-3">3.7</span> 清空目标文件的规则</h3>
<div class="outline-text-3" id="text-3-7">


<p>
   每个Makefile中都应该写一个清空目标文件（.o和执行文件）的规则，这不仅便于重编译，也很利于保持文件的清洁。一般的风格都是：
</p>



<pre class="src src-sh">clean:
        rm edit $(<span style="color: #fa8072;">objects</span>)
</pre>


<p>
更为稳健的做法是：
</p>



<pre class="src src-sh">.PHONY : clean
clean :
        -rm edit $(<span style="color: #fa8072;">objects</span>)
</pre>


<p>
前面说过， .PHONY 意思表示clean是一个“<a href="#sec-4-5">伪目标</a>”。而在rm命令前面加了一个 <b>小减号</b> 的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。当然， <b>clean的规则不要放在文件的开头</b> ，不然，这就会变成make的默认目标，相信谁也不愿意这样。不成文的规矩是——“clean从来都是放在文件的最后”。
</p>
</div>

</div>

<div id="outline-container-3-8" class="outline-3">
<h3 id="sec-3-8"><span class="section-number-3">3.8</span> Makefile里有什么？</h3>
<div class="outline-text-3" id="text-3-8">


<p>
Makefile里主要包含了五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。
</p>
<ol>
<li><a name="" class="target">显式规则</a> 。显式规则说明了，如何生成一个或多的的目标文件。这是由Makefile的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。
</li>
<li>隐晦规则。由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较简略地书写Makefile，这是由make所支持的。
</li>
<li>变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点像你C语言中的宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。
</li>
<li>文件指示。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。
</li>
<li>注释。Makefile中只有 <b>行注释</b> ，和UNIX的Shell脚本一样， <b>其注释是用“#”字符</b> ，这个就像C/C++中的“//”一样。如果你要在你的Makefile中使用“#”字符，可以用反斜框进行转义，如：“\#”。
</li>
</ol>


<p>
最后，还值得一提的是，在Makefile中的命令，必须要以[Tab]键开始。   
</p>
</div>

</div>

<div id="outline-container-3-9" class="outline-3">
<h3 id="sec-3-9"><span class="section-number-3">3.9</span> Makefile的文件名</h3>
<div class="outline-text-3" id="text-3-9">


<p>
   默认的情况下，make命令会在当前目录下按顺序找寻文件名为“GNUmakefile”、“makefile”、“Makefile”的文件，找到了解释这个文件。在这三个文件名中，最好使用“Makefile”这个文件名，因为，这个文件名第一个字符为大写，这样有一种显目的感觉。最好不要用 “GNUmakefile”，这个文件是GNU的make识别的。有另外一些make只对全小写的“makefile”文件名敏感，但是基本上来说，大多数的make都支持“makefile”和“Makefile”这两种默认文件名。
</p>
<p>
   当然，你可以使用别的文件名来书写Makefile，比如：“Make.Linux”，“Make.Solaris”，“Make.AIX”等， <b>如果要指定特定的Makefile，你可以使用make的“-f”和“&ndash;file”参数</b> ，如： <code>make -f Make.Linux</code> 或 <code>make --file Make.AIX</code> 。
</p>
</div>

</div>

<div id="outline-container-3-10" class="outline-3">
<h3 id="sec-3-10"><span class="section-number-3">3.10</span> 引用其它的Makefile</h3>
<div class="outline-text-3" id="text-3-10">


<p>
   在Makefile使用 <b>include</b> 关键字可以把别的Makefile包含进来，这很像C语言的#include，被包含的文件会原模原样的放在当前文件的包含位置。include的语法是：
</p>



<pre class="src src-makefile"><span style="color: #00ffff; font-weight: bold;">include</span> <span style="color: #ffd700; font-style: italic;">&lt;filename&gt;;</span>   
</pre>


<p>
   filename可以是当前操作系统Shell的文件模式（可以包含路径和通配符）。
</p>
<p>   
   在include前面可以有一些空字符，但是绝不能是[Tab]键开始。include和&lt;filename&gt;;可以用一个或多个空格隔开。举个例子，你有这样几个Makefile：a.mk、b.mk、c.mk，还有一个文件叫foo.make，以及一个变量$(bar)，其包含了 e.mk 和 f.mk，那么，下面的语句：
</p>



<pre class="src src-makefile"><span style="color: #00ffff; font-weight: bold;">include</span> <span style="color: #ffd700; font-style: italic;">foo.make</span> *.mk $(<span style="color: #ffd700; font-style: italic;">bar</span>)   
</pre>


<p>
等价于：
</p>



<pre class="src src-makefile"><span style="color: #00ffff; font-weight: bold;">include</span> <span style="color: #ffd700; font-style: italic;">foo.make</span> a.mk b.mk c.mk e.mk f.mk
</pre>


<p>
make命令开始时，会找寻include所指出的其它Makefile，并把其内容安置在当前的位置。就好像C/C++的#include指令一样。如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找：
</p>
<ol>
<li>如果make执行时，有 <code>-I</code> 或 <code>--include-dir</code> 参数，那么make就会在这个参数所指定的目录下去寻找。
</li>
<li>如果目录&lt;prefix&gt;/include（一般是：/usr/local/bin或/usr/include）存在的话，make也会去找。
</li>
</ol>


<p>   
如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成makefile的读取， make会再重试这些没有找到，或是不能读取的文件，如果还是不行，make才会出现一条致命信息。如果你想让make不理那些无法读取的文件，而继续执行，你可以在include前加一个减号“-”。如：
</p>



<pre class="src src-makefile">-include &lt;filename&gt;;
</pre>


<p>
其表示，无论include过程中出现什么错误，都不要报错继续执行。和其它版本make兼容的相关命令是sinclude，其作用和这一个是一样的。
</p>
</div>

</div>

<div id="outline-container-3-11" class="outline-3">
<h3 id="sec-3-11"><span class="section-number-3">3.11</span> 环境变量 MAKEFILES</h3>
<div class="outline-text-3" id="text-3-11">


<p>
   如果你的当前环境中定义了环境变量MAKEFILES，那么，make会把这个变量中的值做一个类似于include的动作。这个变量中的值是其它的Makefile，用空格分隔。只是，它和include不同的是，从这个环境变量中引入的Makefile的“目标”不会起作用，如果环境变量中定义的文件发现错误，make也会不理。
</p>
<p>
   但是在这里我还是 <b>建议不要使用这个环境变量</b> ，因为只要这个变量一被定义，那么当你使用make时，所有的Makefile都会受到它的影响，这绝不是你想看到的。在这里提这个事，只是为了告诉大家，也许有时候你的Makefile出现了怪事，那么你可以看看当前环境中有没有定义这个变量。
</p>
</div>

</div>

<div id="outline-container-3-12" class="outline-3">
<h3 id="sec-3-12"><span class="section-number-3">3.12</span> make的工作方式</h3>
<div class="outline-text-3" id="text-3-12">


<p>
   GNU的make工作时的执行步骤如下：
</p>
<ol>
<li>读入所有的Makefile。
</li>
<li>读入被include的其它Makefile。
</li>
<li>初始化文件中的变量。
</li>
<li>推导隐晦规则，并分析所有规则。
</li>
<li>为所有的目标文件创建依赖关系链。
</li>
<li>根据依赖关系，决定哪些目标要重新生成。
</li>
<li>执行生成命令。
</li>
</ol>


<p>   
1-5步为第一个阶段，6-7为第二个阶段。第一个阶段中，如果定义的变量被使用了，那么，make会把其展开在使用的位置。但make并不会完全马上展开，make使用的是拖延战术，如果变量出现在依赖关系的规则中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。
</p>
<p>
当然，这个工作方式你不一定要清楚，但是知道这个方式你也会对make更为熟悉。有了这个基础，后续部分也就容易看懂了。
</p>
</div>
</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> 书写规则</h2>
<div class="outline-text-2" id="text-4">


<p>
  规则包含两个部分，一个是依赖关系，一个是生成目标的方法。
</p>
<p>
  在Makefile中，规则的顺序是很重要的，因为，Makefile中只应该有一个最终目标，其它的目标都是被这个目标所连带出来的，所以一定要让make知道你的最终目标是什么。一般来说，定义在Makefile中的目标可能会有很多，但是第一条规则中的目标将被确立为最终的目标。如果第一条规则中的目标有很多个，那么，第一个目标会成为最终的目标。make所完成的也就是这个目标。
</p>
<p>
  好了，还是让我们来看一看如何书写规则。
</p>

</div>

<div id="outline-container-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> 规则举例</h3>
<div class="outline-text-3" id="text-4-1">





<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">foo.o</span> : foo.c defs.h       <span style="color: #ffd700;"># </span><span style="color: #ffd700;">foo&#27169;&#22359;</span>
        cc -c -g foo.c
</pre>


</div>

</div>

<div id="outline-container-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> 规则的语法</h3>
<div class="outline-text-3" id="text-4-2">


<p>
   规则的语法
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">targets</span> : prerequisites
        command
        ...
</pre>


<p>   
或是这样：
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">targets</span> : prerequisites ; command
        command
        ...
</pre>


<p>
targets是文件名，以空格分开，可以使用通配符。一般来说，我们的目标基本上是一个文件，但也有可能是多个文件。
</p>
<p>
command是命令行，如果其不与“target:prerequisites”在一行，那么，必须以[Tab键]开头，如果和prerequisites在一行，那么可以用分号做为分隔。
</p>
<p>
prerequisites也就是目标所依赖的文件（或依赖目标）。如果其中的某个文件要比目标文件要新，那么，目标就被认为是“过时的”，被认为是需要重生成的。这个在前面已经讲过了。
</p>
<p>
如果命令太长，你可以使用反斜框（‘\’）作为换行符。make对一行上有多少个字符没有限制。规则告诉make两件事，文件的依赖关系和如何生成目标文件。
</p>
<p>
一般来说，make会以UNIX的标准Shell，也就是/bin/sh来执行命令。
</p>
<p>
或是这样：
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">targets</span> : prerequisites ; command
        command
        ...
</pre>


<p>
targets是文件名，以空格分开，可以使用通配符。一般来说，我们的目标基本上是一个文件，但也有可能是多个文件。
</p>
<p>
command是命令行，如果其不与“target:prerequisites”在一行，那么，必须以[Tab键]开头，如果和prerequisites在一行，那么可以用分号做为分隔。（见上）
</p>
<p>
prerequisites也就是目标所依赖的文件（或依赖目标）。如果其中的某个文件要比目标文件要新，那么，目标就被认为是“过时的”，被认为是需要重生成的。这个在前面已经讲过了。
</p>
<p>
如果命令太长，你可以使用反斜框（‘\’）作为换行符。make对一行上有多少个字符没有限制。规则告诉make两件事，文件的依赖关系和如何生成目标文件。
</p>
<p>
一般来说，make会以UNIX的标准Shell，也就是/bin/sh来执行命令。
</p>
</div>

</div>

<div id="outline-container-4-3" class="outline-3">
<h3 id="sec-4-3"><span class="section-number-3">4.3</span> 在规则中使用通配符</h3>
<div class="outline-text-3" id="text-4-3">


<p>
   如果我们想定义一系列比较类似的文件，我们很自然地就想起使用通配符。make支持三个通配符：
</p>
<ul>
<li>“*”通配符代替了一系列的文件，如“*.c”表示所有后缀为c的文件。一个需要我们注意的是，如果我们的文件名中有通配符，如：“*”，那么可以用转义字符“\”，如“\*”来表示真实的“*”字符，而不是任意长度的字符串。
</li>
<li>“?”匹配一个字符。
</li>
<li>“~”波浪号（“~”）字符在文件名中也有比较特殊的用途。如果是“~/test”，这就表示当前用户的$HOME目录下的test目录。而 “~hchen/test”则表示用户hchen的宿主目录下的test目录。（这些都是Unix下的小知识了，make也支持）而在Windows或是 MS-DOS下，用户没有宿主目录，那么波浪号所指的目录则根据环境变量“HOME”而定。
</li>
</ul>


<p>
   好吧，还是先来看几个例子吧：
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">clean</span>:
        rm -f *.o
</pre>


<p>   
其实在这个clean:后面可以加上你想做的一些事情，如果你想看到在编译完后执行clean看看main.c的源代码，你可以在加上cat这个命令，例子如下：
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">clean</span> :
      cat main.c
      rm -f *.o
</pre>


<p>
其结果你试一下就知道的。 上面这个例子我不不多说了，这是操作系统Shell所支持的通配符。这是在命令中的通配符。
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">print</span>: *.c
        lpr -p $<span style="color: #b0c4de; font-weight: bold;">?</span>
        touch print
</pre>


<p>
上面这个例子说明了 <b>通配符也可以在我们的规则中</b> ，目标print依赖于所有的[.c]文件。其中的“$?”是一个<a href="#sec-10-5-3">自动化变量</a>，我会在后面给你讲述。
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">objects</span> = *.o
</pre>


<p>
上面这个例子，表示了 <b>通配符同样可以用在变量中</b> 。并不是说[*.o]会展开，不！objects的值就是“*.o”。 <b>Makefile中的变量其实就是C/C++中的宏</b> 。如果你要让通配符在变量中展开，也就是让objects的值是所有[.o]的文件名的集合，那么，你可以这样：
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">objects</span> := $(<span style="color: #ffd700; font-style: italic;">wildcard</span> *.o)   
</pre>


<p>
另给一个变量使用通配符的例子：
</p>
<p>
a. 列出一确定文件夹中的所有”.c"文件
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">objects</span> := $(<span style="color: #ffd700; font-style: italic;">wildcard</span> *.c)
</pre>


<p>
b. 列出（a）中所有文件对应的".o"文件，在（c）中我们可以看到它是由make自动编译出的。
</p>



<pre class="src src-makefile">$(patsubst %.c,%.o,$(<span style="color: #ffd700; font-style: italic;">wildcard</span> *.c))
</pre>


<p>
c. 由（a）（b）两步，可写出编译并链接所有“.c”和“.o”文件
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">objects</span> := $(<span style="color: #ffd700; font-style: italic;">patsubst</span> %.c,%.o,$(<span style="color: #ffd700; font-style: italic;">wildcard</span> *.c))
<span style="color: #ffd700; font-weight: bold;">foo</span> : $(<span style="color: #ffd700; font-style: italic;">objects</span>)
        cc -o foo $(<span style="color: #ffd700; font-style: italic;">objects</span>)  
</pre>


<p>
这种用法由<a href="#">关键字</a> <code>wildcard</code> ， <code>patsubst</code> 指出，关于Makefile的<a href="#">关键字</a>，我们将在后面讨论。
</p>
</div>

</div>

<div id="outline-container-4-4" class="outline-3">
<h3 id="sec-4-4"><span class="section-number-3">4.4</span> 文件搜寻</h3>
<div class="outline-text-3" id="text-4-4">


<p>
   在一些大的工程中，有大量的源文件，我们通常的做法是把这许多的源文件分类，并存放在不同的目录中。所以，当make需要去找寻文件的依赖关系时，你可以在文件前加上路径，但最好的方法是把一个路径告诉make，让make在自动去找。
</p>
<p>
   Makefile文件中的特殊变量 <code>VPATH</code> 就是完成这个功能的，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，make就会在当前目录找不到的情况下，到所指定的目录中去找寻文件了。
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">VPATH</span> = src:../headers
</pre>


<p>
上面的的定义指定两个目录，“src”和“../headers”，make会按照这个顺序进行搜索。目录由“冒号”分隔。（当然，当前目录永远是最高优先搜索的地方）
</p>
<p>
另一个设置文件搜索路径的方法是使用make的“vpath”关键字（注意，它是全小写的），这不是变量，这是一个make的关键字，这和上面提到的那个VPATH变量很类似，但是它更为灵活。它可以指定不同的文件在不同的搜索目录中。这是一个很灵活的功能。它的使用方法有三种：
</p>
<p>
1、 <code>vpath &lt;pattern&gt; &lt;directories&gt;</code>
</p>
<p>
为符合模式&lt;pattern&gt;的文件指定搜索目录&lt;directories&gt;。
</p>
<p>
2、 <code>vpath &lt;pattern&gt;</code>
</p>
<p>
清除符合模式&lt;pattern&gt;的文件的搜索目录。
</p>
<p>
3、 <code>vpath</code>
</p>
<p>
清除所有已被设置好了的文件搜索目录。
</p>
<ul>
<li>&lt;pattern&gt; 指定了要搜索的文件集，需要包含“%”字符* 。“%”的意思是匹配零或若干字符，（需引用“%”，使用“\%"）例如，“%.h”表示所有以 “.h”结尾的文件。  
</li>
<li>&lt;directories&gt; 指定了&lt;pattern&gt;的文件集的搜索的目录。例如：



<pre class="example">vpath %.h ../headers
</pre>

</li>
</ul>


<p>
该语句表示，要求make在“../headers”目录下搜索所有以“.h”结尾的文件。（如果某文件在当前目录没有找到的话）
</p>
<p>
我们 <b>可以连续地使用vpath语句</b> ，以指定不同搜索策略。如果连续的vpath语句中出现了相同的&lt;pattern&gt;，或是被重复了的&lt;pattern&gt;，那么，make会按照vpath语句的先后顺序来执行搜索。如：
</p>



<pre class="src src-makefile">vpath %.c foo
vpath %.c blish
vpath %.c bar
</pre>


<p>
其表示“.c”结尾的文件，先在“foo”目录，然后是“blish”，最后是“bar”目录。
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">vpath %.c foo</span>:bar
vpath %.c blish
</pre>


<p>
而上面的语句则表示“.c”结尾的文件，先在“foo”目录，然后是“bar”目录，最后才是“blish”目录。
</p>
</div>

</div>

<div id="outline-container-4-5" class="outline-3">
<h3 id="sec-4-5"><span class="section-number-3">4.5</span> <span class="target">伪目标</span></h3>
<div class="outline-text-3" id="text-4-5">


<p>
   最早先的一个例子中，我们提到过一个“clean”的目标，这是一个“伪目标”，
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">clean</span>:
        rm *.o temp
</pre>


<p>   
正像我们前面例子中的“clean”一样，既然我们生成了许多文件编译文件，我们也应该提供一个清除它们的“目标”以备完整地重编译而用。 （以“make clean”来使用该目标）
</p>
<p>
因为，我们 <b>并不生成“clean”这个文件</b> 。“伪目标”并不是一个文件，只是一个标签，由于“伪目标”不是文件，所以make无法生成它的依赖关系和决定它是否要执行。我们只有通过显式地指明这个“目标”才能让其生效。当然， <b>“伪目标”的取名不能和文件名重名</b> ，不然其就失去了“伪目标”的意义了。
</p>
<p>
当然，为了避免和文件重名的这种情况，我们可以使用一个特殊的标记“.PHONY”来显式地指明一个目标是“伪目标”，向make说明，不管是否有这个文件，这个目标就是“伪目标”。
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">.PHONY</span> : clean
</pre>


<p>
只要有这个声明，不管是否有“clean”文件，要运行“clean”这个目标，只有使用命令 <code>make clean</code> 。于是整个过程可以这样写：
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">.PHONY</span> : clean
<span style="color: #ffd700; font-weight: bold;">clean</span> :
        rm *.o temp
</pre>


<p>
伪目标一般没有依赖的文件。但是， <b>我们也可以为伪目标指定所依赖的文件</b> 。 <b>伪目标同样可以作为“默认目标”，只要将其放在第一个</b> 。
</p>
<p>
示例：如果你的Makefile需要 <b>一口气生成若干个可执行文件</b> ，但你只想简单地敲一个make完事，并且，所有的目标文件都写在一个Makefile中，那么你可以使用“伪目标”这个特性：
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">all</span> : prog1 prog2 prog3
<span style="color: #ffd700; font-weight: bold;">.PHONY</span> : all

<span style="color: #ffd700; font-weight: bold;">prog1</span> : prog1.o utils.o
        cc -o prog1 prog1.o utils.o

<span style="color: #ffd700; font-weight: bold;">prog2</span> : prog2.o
        cc -o prog2 prog2.o

<span style="color: #ffd700; font-weight: bold;">prog3</span> : prog3.o sort.o utils.o
        cc -o prog3 prog3.o sort.o utils.o
</pre>


<p>
我们知道，Makefile中的第一个目标会被作为其默认目标。我们声明了一个“all”的伪目标，其依赖于其它三个目标。由于默认目标的特性是，总是被执行的，但由于“all”又是一个伪目标，伪目标只是一个标签不会生成文件，所以 <b>不会有“all”文件产生</b> 。于是，其它三个目标的规则总是会被决议。也就达到了我们一口气生成多个目标的目的。“.PHONY : all”声明了“all”这个目标为“伪目标”。（注：这里的显式 “.PHONY : all" 不写的话一般情况也可以正确的执行，这样 make 可通过隐式规则推导出， “all” 是一个伪目标，执行 make 不会生成“all”文件，而执行后面的多个目标。建议： <b>显式写出是一个好习惯。</b> ）
</p>
<p>
随便提一句，从上面的例子我们可以看出，目标也可以成为依赖。所以， <b>伪目标同样也可成为依赖</b> 。看下面的例子：
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">.PHONY</span> : cleanall cleanobj cleandiff

<span style="color: #ffd700; font-weight: bold;">cleanall</span> : cleanobj cleandiff <span style="color: #ffd700;">#</span><span style="color: #ffd700;">cleanobj&#21644;cleandiff&#20316;&#20026;cleanall&#30340;&#20381;&#36182;</span>
        rm program

<span style="color: #ffd700; font-weight: bold;">cleanobj</span> :
        rm *.o

<span style="color: #ffd700; font-weight: bold;">cleandiff</span> :
        rm *.diff
</pre>


<p>
<code>make cleanall</code> 将清除所有要被清除的文件。“cleanobj”和“cleandiff”这两个伪目标有点像“子程序”的意思。我们可以输入“make cleanall”和“make cleanobj”和“make cleandiff”命令来达到清除不同种类文件的目的。
</p>
</div>

</div>

<div id="outline-container-4-6" class="outline-3">
<h3 id="sec-4-6"><span class="section-number-3">4.6</span> 多目标</h3>
<div class="outline-text-3" id="text-4-6">


<p>
   Makefile的规则中的目标可以不止一个，其支持多目标，有可能我们的多个目标同时依赖于一个文件，并且其生成的命令大体类似。于是我们就能把其合并起来。当然，多个目标的生成规则的执行命令不是同一个，这可能会给我们带来麻烦，不过好在我们可以使用一个<a href="#sec-10-5-3">自动化变量</a> <code>$@</code> ，这个变量表示着目前规则中所有的目标的集合，这样说可能很抽象，还是看一个例子吧。
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">bigoutput littleoutput</span> : text.g
        generate text.g -$(<span style="color: #ffd700; font-style: italic;">subst</span> output,,<span style="color: #ffd700; font-weight: bold;">$</span><span style="color: #ffd700; font-weight: bold;">@</span>) &gt; <span style="color: #ffd700; font-weight: bold;">$</span><span style="color: #ffd700; font-weight: bold;">@</span>
</pre>


<p>
   上述规则等价于：
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">bigoutput</span> : text.g
        generate text.g -big &gt; bigoutput
<span style="color: #ffd700; font-weight: bold;">littleoutput</span> : text.g
        generate text.g -little &gt; littleoutput
</pre>


<p>   
其中， <code>-$(subst output,,$@)</code> 中的“$”表示执行一个Makefile的<a href="#sec-8">函数</a>，函数名为subst，后面的为参数。这里的这个函数是替换字符串的意思，“$@”表示目标的集合，就像一个数组，“$@”依次取出目标，并执于命令。
</p>
</div>

</div>

<div id="outline-container-4-7" class="outline-3">
<h3 id="sec-4-7"><span class="section-number-3">4.7</span> <span class="target">静态模式</span></h3>
<div class="outline-text-3" id="text-4-7">


<p>
   静态模式可以 <b>更加容易地定义多目标的规则</b> ，可以让我们的规则变得更加的有弹性和灵活。我们还是先来看一下语法:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">&lt;targets ...&gt;</span>: &lt;target-pattern&gt;: &lt;prereq-patterns ...&gt;
        &lt;commands&gt;
        ....
</pre>


<ul>
<li>targets 定义了一系列的 <b>目标文件</b> ，可以有通配符。是目标的一个集合。
</li>
<li>target-parrtern 指明了 targets 的模式，也就是的 <b>目标集模式</b> 。
</li>
<li>prereq-parrterns 是 <b>目标的依赖模式</b> ，它对 target-parrtern 形成的模式再进行一次依赖目标的定义。

<p>     
     这样描述这三个东西，可能还是没有说清楚，还是举个例子来说明一下吧。如果我们的&lt;target-parrtern&gt;定义成“%.o”，意思是我们的&lt;target&gt;集合中都是以“.o”结尾的，而如果我们的&lt;prereq-parrterns&gt;定义成“%.c”，意思是对&lt;target-parrtern&gt;所形成的目标集进行二次定义，其计算方法是，取&lt;target-parrtern&gt;模式中的“%”(也就是去掉了[.o]这个结尾)，并为其加上[.c]这个结尾，形成的新集合。
</p>
<p>     
     所以，我们的“目标模式”或是“依赖模式”中都应该有“%”这个字符，如果你的文件名中有“%”那么你可以使用反斜杠“\”进行转义，来标明真实的“%”字符。
</p>
<p>     
     看一个例子:
</p></li>
</ul>





<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">objects</span> = foo.o bar.o
<span style="color: #ffd700; font-style: italic;">CFLAGS</span> = $(<span style="color: #ffd700; font-style: italic;">include_dirs</span>) -O
<span style="color: #ffd700; font-style: italic;">include_dirs</span> = -Ifoo -Ibar

<span style="color: #ffd700; font-weight: bold;">all</span>: $(<span style="color: #ffd700; font-style: italic;">objects</span>)

<span style="color: #ffd700; font-weight: bold;">$(</span><span style="color: #ffd700; font-weight: bold; font-style: italic;">objects</span><span style="color: #ffd700; font-weight: bold;">)</span>: %.o: %.c
        $(<span style="color: #ffd700; font-style: italic;">CC</span>) -c $(<span style="color: #ffd700; font-style: italic;">CFLAGS</span>) $<span style="color: #b0c4de; font-weight: bold;">&lt;</span> -o <span style="color: #ffd700; font-weight: bold;">$</span><span style="color: #ffd700; font-weight: bold;">@</span>
</pre>


<p>
   上面的例子中，指明了我们的目标从$object 中获取，“%.o”表明要所有以“.o”结尾的目标，也就是“foo.o bar.o”，也就是变量 $object 集合的模式，而依赖模式“%.c”则取模式“%.o”的“%”，也就是“foo bar”，并为其加下“.c”的后缀，于是，我们的依赖目标就是“foo.c bar.c”。而命令中的“$&lt;”和“$@”则是<a href="#sec-10-5-3">自动化变量</a>， <b>“$&lt;”表示所有的依赖目标集</b> (也就是“foo.c bar.c”) ，  <b>“$@”表示目标集(也就是“foo.o bar.o”)</b> 。于是，上面的规则展开后等价于下面的规则:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">foo.o</span> : foo.c
        $(<span style="color: #ffd700; font-style: italic;">CC</span>) -c $(<span style="color: #ffd700; font-style: italic;">CFLAGS</span>) foo.c -o foo.o
<span style="color: #ffd700; font-weight: bold;">bar.o</span> : bar.c
        $(<span style="color: #ffd700; font-style: italic;">CC</span>) -c $(<span style="color: #ffd700; font-style: italic;">CFLAGS</span>) bar.c -o bar.o
</pre>


<p>
试想，如果我们的“%.o”有几百个，那种我们只要用这种很简单的“静态模式规则”就可以写完一堆规则，实在是太有效率了。“静态模式规则”的用法很灵活，如果用得好，那会一个很强大的功能。再看一个例子:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">files</span> = foo.elc bar.o lose.o

<span style="color: #ffd700; font-weight: bold;">$(</span><span style="color: #ffd700; font-weight: bold; font-style: italic;">filter</span><span style="color: #ffd700; font-weight: bold;"> %.o,$(</span><span style="color: #ffd700; font-weight: bold; font-style: italic;">files</span><span style="color: #ffd700; font-weight: bold;">))</span>: %.o: %.c
        $(<span style="color: #ffd700; font-style: italic;">CC</span>) -c $(<span style="color: #ffd700; font-style: italic;">CFLAGS</span>) $<span style="color: #b0c4de; font-weight: bold;">&lt;</span> -o <span style="color: #ffd700; font-weight: bold;">$</span><span style="color: #ffd700; font-weight: bold;">@</span>
<span style="color: #ffd700; font-weight: bold;">$(</span><span style="color: #ffd700; font-weight: bold; font-style: italic;">filter</span><span style="color: #ffd700; font-weight: bold;"> %.elc,$(</span><span style="color: #ffd700; font-weight: bold; font-style: italic;">files</span><span style="color: #ffd700; font-weight: bold;">))</span>: %.elc: %.el
        emacs -f batch-byte-compile $<span style="color: #b0c4de; font-weight: bold;">&lt;</span>
</pre>


<p>
$(filter %.o，$(files))表示调用 Makefile 的 filter 函数，过滤“$filter”集，只要其
中模式为“%.o”的内容。其的它内容，我就不用多说了吧。这个例子展示了 Makefile 中更
大的弹性。
</p>
</div>

</div>

<div id="outline-container-4-8" class="outline-3">
<h3 id="sec-4-8"><span class="section-number-3">4.8</span> 自动生成依赖性</h3>
<div class="outline-text-3" id="text-4-8">


<p>
   在 Makefile 中， 我们的依赖关系可能会需要包含一系列的头文件， 比如， 如果我们的 main.c
中有一句“#include "defs.h"”，那么我们的依赖关系应该是:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">main.o</span> : main.c defs.h
</pre>


<p>
但是，如果是一个比较大型的工程，你必需清楚哪些 C 文件包含了哪些头文件，并且，你在加入或删除头文件时，也需要小心地修改 Makefile，这是一个很没有维护性的工作。为了避免这种繁重而又容易出错的事情，我们可以使用 C/C++编译的一个功能。 <b>大多数的C/C++编译器都支持一个“-M”的选项，即自动找寻源文件中包含的头文件，并生成一个依赖关系。</b> 例如，如果我们执行下面的命令:
</p>



<pre class="src src-makefile">cc -M main.c
</pre>


<p>
其输出是:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">main.o</span> : main.c defs.h
</pre>


<p>
于是由编译器自动生成的依赖关系，这样一来，你就不必再手动书写若干文件的依赖关系，而由编译器自动生成了。需要提醒一句的是， <b>如果你使用 GNU 的 C/C++编译器，你得用“-MM”参数</b> ，不然，“-M”参数会把一些标准库的头文件也包含进来。
</p>
<p>
那么，编译器的这个功能如何与我们的 Makefile 联系在一起呢。因为这样一来，我们的Makefile 也要根据这些源文件重新生成，让 Makefile 自已依赖于源文件?这个功能并不现实，不过我们可以有其它手段来迂回地实现这一功能。GNU 组织建议把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，为每一个“name.c”的文件都生成一个“name.d”的 Makefile 文件，[.d]文件中就存放对应[.c]文件的依赖关系。于是，我们可以写出[.c]文件和[.d]文件的依赖关系，并 <b>让 make 自动更新或生成[.d]文件</b> ，并把其包含在我们的主 Makefile 中，这样，我们就可以自动化地生成每个文件的依赖关系了。这里，我们给出了一个模式规则来产生[.d]文件:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">%.d</span>: %.c
        @set -e; rm -f <span style="color: #ffd700; font-weight: bold;">$</span><span style="color: #ffd700; font-weight: bold;">@</span>; \
        $(<span style="color: #ffd700; font-style: italic;">CC</span>) -M $(<span style="color: #ffd700; font-style: italic;">CPPFLAGS</span>) $<span style="color: #b0c4de; font-weight: bold;">&lt;</span> &gt; <span style="color: #ffd700; font-weight: bold;">$</span><span style="color: #ffd700; font-weight: bold;">@</span>.$$$$; \
        sed <span style="color: #f0e68c;">'s,\(</span><span style="color: #ffd700; font-weight: bold;">$</span><span style="color: #ffd700; font-weight: bold;">*</span><span style="color: #f0e68c;">\)\.o[ :]*,\1.o </span><span style="color: #ffd700; font-weight: bold;">$</span><span style="color: #ffd700; font-weight: bold;">@</span><span style="color: #f0e68c;"> : ,g'</span> &lt; <span style="color: #ffd700; font-weight: bold;">$</span><span style="color: #ffd700; font-weight: bold;">@</span>.$$$$ &gt; <span style="color: #ffd700; font-weight: bold;">$</span><span style="color: #ffd700; font-weight: bold;">@</span>; \
        rm -f <span style="color: #ffd700; font-weight: bold;">$</span><span style="color: #ffd700; font-weight: bold;">@</span>.$$$$
</pre>


<p>
这个规则的意思是，所有的[.d]文件依赖于[.c]文件，“rm -f $@”的意思是删除所有的目标，也就是[.d]文件，第二行的意思是，为每个依赖文件“$&lt;”，也就是[.c]文件生成依赖文件，“$@”表示模式“%.d”文件，如果有一个 C 文件是 name.c，那么“%”就是“name”，“$$$$”意为一个随机编号，第二行生成的文件有可能是“name.d.12345”，第三行使用 sed 命令做了一个替换，第四行就是删除临时文件。
</p>
<p>
总而言之，这个模式要做的事就是在编译器生成的依赖关系中加入[.d]文件的依赖，即把依赖关系:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">main.o</span> : main.c defs.h
</pre>


<p>
转成：
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">main.o main.d</span> : main.c defs.h
</pre>


<p>
于是，我们的[.d]文件也会自动更新了，并会自动生成了，当然，你还可以在这个[.d]文件中加入的不只是依赖关系，包括生成的命令也可一并加入，让每个[.d]文件都包含一个完赖的规则。一旦我们完成这个工作，接下来，我们就要把这些自动生成的规则放进我们的主 Makefile 中。
</p>
<p>
我们可以使用 Makefile 的“include”命令，来引入别的 Makefile 文件(前面讲过)，例如:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">sources</span> = foo.c bar.c
<span style="color: #00ffff; font-weight: bold;">include</span> $(<span style="color: #ffd700; font-style: italic;">sources</span>:<span style="color: #ffd700; font-style: italic;">.c</span>=.d)
</pre>


<p>
上述语句中的“$(sources:.c=.d)”中的“.c=.d”的意思是做一个替换，把变量$(sources)所有[.c]的字串都替换成[.d]，关于这个“替换”的内容，在后面我会有更为详细的讲述。当然，你得注意次序，因为 include 是按次来载入文件，最先载入的[.d]文件中的目标会成为默认目标。
</p>
</div>
</div>

</div>

<div id="outline-container-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> 书写命令</h2>
<div class="outline-text-2" id="text-5">



</div>

<div id="outline-container-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> 显示命令</h3>
<div class="outline-text-3" id="text-5-1">


<p>
   通常，make 会把其要执行的命令行在命令执行前输出到屏幕上。当我们用“@”字符在命令行前，那么，这个命令将不被 make 显示出来，最具代表性的例子是，我们用这个功能来像屏幕显示一些信息。如:
</p>



<pre class="src src-makefile">@echo &#27491;&#22312;&#32534;&#35793; XXX &#27169;&#22359;......
</pre>


<p>
当 make 执行时，会输出“正在编译 XXX 模块&hellip;&hellip;”字串，但不会输出命令，如果没有“@”，那么，make 将输出:
</p>



<pre class="src src-sh"><span style="color: #00ffff; font-weight: bold;">echo</span> &#27491;&#22312;&#32534;&#35793; XXX &#27169;&#22359;......
&#27491;&#22312;&#32534;&#35793; XXX &#27169;&#22359;......
</pre>


<p>
如果 make 执行时，带入 make 参数“-n”或“&ndash;just-print”，那么其 <b>只是显示命令，但不会执行命令</b> ，这个功能很有利于我们调试我们的 Makefile，看看我们书写的命令是执行起来是什么样子的或是什么顺序的。
</p>
<p>
而 make 参数“-s”或“&ndash;slient”则是 <b>全面禁止命令的显示</b> 。
</p>
</div>

</div>

<div id="outline-container-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> 命令执行</h3>
<div class="outline-text-3" id="text-5-2">


<p>
   当依赖目标新于目标时，也就是当规则的目标需要被更新时，make 会一条一条的执行其后的命令。需要注意的是，如果你要让上一条命令的结果应用在下一条命令时，你应该 <b>使用分号分隔这两条命令</b> 。比如你的第一条命令是 cd 命令，你希望第二条命令得在 cd 之后的基础上运行，那么你就不能把这两条命令写在两行上，而应该把这两条命令写在一行上，用分号分隔。如:
</p>
<p>
   示例一：
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">exec</span>:
        cd /home/hchen
        pwd
</pre>


<p>
   示例二：
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">exec</span>:
        cd /home/hchen; pwd
</pre>


<p>
   当我们执行“make exec”时，第一个例子中的 cd 没有作用，pwd 会打印出当前的Makefile 目录，而第二个例子中，cd 就起作用了，pwd 会打印出“/home/hchen”。make一般是使用环境变量 SHELL 中所定义的系统 Shell 来执行命令，默认情况下使用 UNIX 的标准 Shell——/bin/sh 来执行命令。但在 MS-DOS 下有点特殊，因为 MS-DOS 下没有 SHELL环境变量，当然你也可以指定。如果你指定了 UNIX 风格的目录形式，首先，make 会在 SHELL所指定的路径中找寻命令解释器，如果找不到，其会在当前盘符中的当前目录中寻找，如果再找不到，其会在 PATH 环境变量中所定义的所有路径中寻找。MS-DOS 中，如果你定义的命令解释器没有找到，其会给你的命令解释器加上诸如“.exe”、“.com”、“.bat”、“.sh”等后缀。
</p>
</div>

</div>

<div id="outline-container-5-3" class="outline-3">
<h3 id="sec-5-3"><span class="section-number-3">5.3</span> 命令出错</h3>
<div class="outline-text-3" id="text-5-3">


<p>
   每当命令运行完后，make 会检测每个命令的返回码，如果命令返回成功，那么 make 会执行下一条命令，当规则中所有的命令成功返回后，这个规则就算是成功完成了。如果一个规则中的某个命令出错了(命令退出码非零)，那么 make 就会 <b>终止执行当前规则，这将有可能终止所有规则的执行</b> 。
</p>
<p>
   有些时候，命令的出错并不表示就是错误的。例如 mkdir 命令，我们一定需要建立一个目录，如果目录不存在，那么 mkdir 就成功执行，万事大吉，如果目录存在，那么就出错了。我们之所以使用 mkdir 的意思就是一定要有这样的一个目录，于是我们就不希望 mkdir 出错而终止规则的运行。
</p>
<p>
   为了做到这一点， <b>忽略命令的出错</b> ，我们可以在 Makefile 的命令行前加 <b>一个减号“-”</b> (在 Tab 键之后)，标记为不管命令出不出错都认为是成功的。如:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">clean</span>:
        -rm -f *.o
</pre>


<p>
   还有一个 <b>全局的办法</b> 是，给 make 加上“-i”或是“&ndash;ignore-errors”参数，那么，Makefile 中 <b>所有命令都会忽略错误</b> 。而如果一个规则是以“.IGNORE”作为目标的，那么这个规则中的所有命令将会忽略错误。这些是不同级别的防止命令出错的方法，你可以根据你的不同喜欢设置。
</p>
<p>
   还有一个要提一下的 make 的参数的是“-k”或是“&ndash;keep-going”，这个参数的意思是，如果某规则中的命令出错了，那么就 <b>终止该规则的执行，但继续执行其它规则</b> 。
</p>
</div>

</div>

<div id="outline-container-5-4" class="outline-3">
<h3 id="sec-5-4"><span class="section-number-3">5.4</span> <span class="target">嵌套执行 make</span></h3>
<div class="outline-text-3" id="text-5-4">


<p>
   在一些大的工程中，我们会把我们不同模块或是不同功能的源文件放在不同的目录中，我们可以在每个目录中都书写一个该目录的 Makefile，这有利于让我们的 Makefile 变得更加地简洁，而不至于把所有的东西全部写在一个 Makefile 中，这样会很难维护我们的 Makefile，这个技术对于我们模块编译和分段编译有着非常大的好处。
</p>
<p>
   例如，我们有一个子目录叫 subdir，这个目录下有个 Makefile 文件，来指明了这个目录下文件的编译规则。那么我们总控的 Makefile 可以这样书写:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">subsystem</span>:
        cd subdir &amp;&amp; $(<span style="color: #ffd700; font-style: italic;">MAKE</span>)
</pre>


<p>   
其等价于:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">subsystem</span>:
        $(<span style="color: #ffd700; font-style: italic;">MAKE</span>) -C subdir
</pre>


<p>
定义$(MAKE)宏变量的意思是，也许我们的 make 需要一些参数，所以定义成一个变量比较利于维护。这两个例子的意思都是先进入“subdir”目录，然后执行 make 命令。
</p>

</div>

<div id="outline-container-5-4-1" class="outline-4">
<h4 id="sec-5-4-1"><span class="section-number-4">5.4.1</span> <span class="target">参数传递</span></h4>
<div class="outline-text-4" id="text-5-4-1">


<p>
我们把这个 Makefile 叫做“总控 Makefile”，总控 Makefile 的变量可以传递到下级的 Makefile 中(如果你显式的声明)，但是不会覆盖下层的 Makefile 中所定义的变量，除非指定了 <code>-e</code> 参数。
</p>
<p>
如果你要传递变量到下级 Makefile 中，那么你可以使用这样的声明:
</p>



<pre class="src src-makefile">export &lt;variable ...&gt;
</pre>


<p>
如果你不想让某些变量传递到下级 Makefile 中，那么你可以这样声明:
</p>



<pre class="src src-makefile">unexport &lt;variable ...&gt;
</pre>


<p>
如:
</p>
<p>
示例一:
</p>



<pre class="src src-makefile">export <span style="color: #ffd700; font-style: italic;">variable</span> = value
</pre>


<p>
其等价于:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">variable</span> = value
export variable
</pre>


<p>
其等价于:
</p>


<pre class="src src-makefile">export <span style="color: #ffd700; font-style: italic;">variable</span> := value
</pre>


<p>
其等价于:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">variable</span> := value
export variable
</pre>


<p>
示例二:
</p>



<pre class="src src-makefile">export <span style="color: #ffd700; font-style: italic;">variable</span> += value
</pre>


<p>
其等价于:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">variable</span> += value
export variable
</pre>


<p>
如果你要传递所有的变量，那么，只要一个 export 就行了。后面什么也不用跟，表示传递所有的变量。
</p>
<p>
需要注意的是，有两个变量，一个是 SHELL，一个是 MAKEFLAGS，这两个变量不管你是否 export，其总是要传递到下层 Makefile 中，特别是 MAKEFILES 变量，其中包含了 make 的参数信息，如果我们执行“总控 Makefile”时有 make 参数或是在上层 Makefile 中定义了这个变量，那么 MAKEFILES 变量将会是这些参数，并会传递到下层 Makefile 中，这是一个系统级的环境变量。
</p>
<p>
但是 make 命令中的有几个参数并不往下传递，它们是“-C”，“-f”，“-h”“-o”和“-W”(有关 Makefile 参数的细节将在后面说明)，如果你不想往下层传递参数，那么，你可以这样来:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">subsystem</span>:
        cd subdir &amp;&amp; $(<span style="color: #ffd700; font-style: italic;">MAKE</span>) MAKEFLAGS= 
</pre>


<p>
如果你定义了环境变量 MAKEFLAGS，那么你得确信其中的选项是大家都会用到的，如果其中有“-t”，“-n”，和“-q”参数，那么将会有让你意想不到的结果，或许会让你异常地恐慌。
</p>
<p>
还有一个在“嵌套执行”中比较有用的参数，“-w”或是“&ndash;print-directory”会在make 的过程中输出一些信息，让你看到目前的工作目录。比如，如果我们的下级 make 目录是“/home/hchen/gnu/make”，如果我们使用“make -w”来执行，那么当进入该目录时，我们会看到:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">make</span>: Entering directory <span style="color: #f0e68c;">`/home/hchen/gnu/make'.</span>
</pre>


<p>
而在完成下层 make 后离开目录时，我们会看到:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">make</span>: Leaving directory <span style="color: #f0e68c;">`/home/hchen/gnu/make'</span>
</pre>


<p>
当你使用“-C”参数来指定 make 下层 Makefile 时，“-w”会被自动打开的。如果参数中有“-s”(“&ndash;slient”)或是“&ndash;no-print-directory”，那么，“-w”总是失效的。
</p>
</div>
</div>

</div>

<div id="outline-container-5-5" class="outline-3">
<h3 id="sec-5-5"><span class="section-number-3">5.5</span> 定义命令包</h3>
<div class="outline-text-3" id="text-5-5">


<p>   
如果 Makefile 中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以“define”开始，以“endef”结束，如:
</p>



<pre class="src src-makefile">define run-yacc
yacc $(<span style="color: #ffd700; font-style: italic;">firstword</span> $<span style="color: #b0c4de; font-weight: bold;">^</span>)
mv y.tab.c <span style="color: #ffd700; font-weight: bold;">$</span><span style="color: #ffd700; font-weight: bold;">@</span>
endef
</pre>


<p>
这里，“run-yacc”是这个命令包的名字，其不要和 Makefile 中的变量重名。在“define”和“endef”中的两行就是命令序列。这个命令包中的第一个命令是运行 Yacc程序，因为 Yacc 程序总是生成“y.tab.c”的文件，所以第二行的命令就是把这个文件改改名字。还是把这个命令包放到一个示例中来看看吧。
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">foo.c</span> : foo.y
$(<span style="color: #ffd700; font-style: italic;">run-yacc</span>)
</pre>


<p>
我们可以看见，要使用这个命令包，我们就好像使用变量一样。在这个命令包的使用中，命令包“run-yacc”中的“$<sup>”就是“foo</sup>.y”，“$@”就是“foo.c”(有关这种以“$”开头的特殊变量，我们会在后面介绍)，make 在执行命令包时，命令包中的每个命令会被依次独立执行。
</p>
</div>
</div>

</div>

<div id="outline-container-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> 使用变量</h2>
<div class="outline-text-2" id="text-6">


<p>
   在 Makefile 中的定义的变量，就像是 C/C++语言中的宏一样，他代表了一个文本字串，在 Makefile 中执行的时候其会自动原模原样地展开在所使用的地方。其与 C/C++所不同的是，你可以在 Makefile 中改变其值。在 Makefile 中，变量可以使用在“目标”，“依赖目标”，“命令”或是 Makefile 的其它部分中。变量的命名字可以包含 <b>字符、数字，下划线(可以是数字开头)</b> ，但不应该含有“:”、“#”、“=”或是空字符(空格、回车等)。变量是 <b>大小写敏感</b> 的，“foo”、“Foo”和“FOO”是三个不同的变量名。传统的 Makefile 的变量名是全大写的命名方式，但我推荐使用大小写搭配的变量名，如:MakeFlags。这样可以避免和系统的变量冲突，而发生意外的事情。
</p>
<p>
   有一些变量是很奇怪字串，如“$&lt;”、“$@”等，这些是<a href="#sec-10-5-3">自动化变量</a>，我会在后面介绍。
</p>

</div>

<div id="outline-container-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> 变量的基础</h3>
<div class="outline-text-3" id="text-6-1">


<p>
    变量在声明时需要给予初值，而在使用时，需要给在变量名前加上“$”符号，但最好用小括号“()”或是大括号“{}”把变量给包括起来。如果你要使用真实的“$”字符，那么你需要用“$$”来表示。
</p>
<p>
    变量可以使用在许多地方，如规则中的“目标”、“依赖”、“命令”以及新的变量中。先看一个例子:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">objects</span> = program.o foo.o utils.o
<span style="color: #ffd700; font-weight: bold;">program</span> : $(<span style="color: #ffd700; font-style: italic;">objects</span>)
        cc -o program $(<span style="color: #ffd700; font-style: italic;">objects</span>)
<span style="color: #ffd700; font-weight: bold;">$(</span><span style="color: #ffd700; font-weight: bold; font-style: italic;">objects</span><span style="color: #ffd700; font-weight: bold;">)</span> : defs.h
</pre>


<p>    
变量会在使用它的地方精确地展开，就像 C/C++ 中的宏一样，例如:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">foo</span> = c
<span style="color: #ffd700; font-weight: bold;">prog.o</span> : prog.$(<span style="color: #ffd700; font-style: italic;">foo</span>)
        $(<span style="color: #ffd700; font-style: italic;">foo</span>)$(<span style="color: #ffd700; font-style: italic;">foo</span>) -$(<span style="color: #ffd700; font-style: italic;">foo</span>) prog.$(<span style="color: #ffd700; font-style: italic;">foo</span>)
</pre>


<p>
展开后得到:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">prog.o</span> : prog.c
        cc -c prog.c
</pre>


<p>
当然，千万不要在你的 Makefile 中这样干，这里只是举个例子来表明 Makefile 中的变量在使用处展开的真实样子。可见其就是一个 <b>“替代”</b> 的原理。
</p>
<p>
另外，给变量加上括号完全是为了更加安全地使用这个变量，在上面的例子中，如果你不想给变量加上括号，那也可以，但我还是强烈建议你给变量加上括号。
</p>
</div>

</div>

<div id="outline-container-6-2" class="outline-3">
<h3 id="sec-6-2"><span class="section-number-3">6.2</span> 变量中的变量</h3>
<div class="outline-text-3" id="text-6-2">


<p>
    在定义变量的值时，我们可以使用其它变量来构造变量的值，在 Makefile 中有两种方式来在用变量定义变量的值。
</p>
<p>
    先看第一种方式，也就是简单的使用“=”号，在“=”左侧是变量，右侧是变量的值，右侧变量的值可以定义在文件的任何一处，也就是说，右侧中的变量不一定非要是已定义好的值，其也可以使用后面定义的值。如:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">foo</span> = $(<span style="color: #ffd700; font-style: italic;">bar</span>)
<span style="color: #ffd700; font-style: italic;">bar</span> = $(<span style="color: #ffd700; font-style: italic;">ugh</span>)
<span style="color: #ffd700; font-style: italic;">ugh</span> = Huh?
<span style="color: #ffd700; font-weight: bold;">all</span>:
        echo $(<span style="color: #ffd700; font-style: italic;">foo</span>)
</pre>


<p>    
我们执行“make all”将会打出变量$(foo)的值是“Huh?”( $(foo)的值是$(bar)，$(bar)的值是$(ugh)，$(ugh)的值是“Huh?”)可见，变量是可以使用后面的变量来定义的。
</p>
<p>
这个功能有好的地方，也有不好的地方，好的地方是，我们可以把变量的真实值推到后面来定义，如:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">CFLAGS</span> = $(<span style="color: #ffd700; font-style: italic;">include_dirs</span>) -O
<span style="color: #ffd700; font-style: italic;">include_dirs</span> = -Ifoo -Ibar
</pre>


<p>
当“CFLAGS”在命令中被展开时，会是“-Ifoo -Ibar -O”。但这种形式也有不好的地方，那就是递归定义，如:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">CFLAGS</span> = $(<span style="color: #ffd700; font-style: italic;">CFLAGS</span>) -O
</pre>


<p>
或:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">A</span> = $(<span style="color: #ffd700; font-style: italic;">B</span>)
<span style="color: #ffd700; font-style: italic;">B</span> = $(<span style="color: #ffd700; font-style: italic;">A</span>)
</pre>


<p>
这会让 make 陷入无限的变量展开过程中去，当然，我们的 make 是有能力检测这样的定义，并会报错。还有就是如果在变量中使用函数，那么，这种方式会让我们的 make 运行时非常慢，更糟糕的是，他会使用得两个 make 的函数“wildcard”和“shell”发生不可预知的错误。因为你不会知道这两个函数会被调用多少次。
</p>
<p>
为了避免上面的这种方法，我们可以使用 make 中的另一种用变量来定义变量的方法。这种方法使用的是 <code>:=</code> 操作符，如:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">x</span> := foo
<span style="color: #ffd700; font-style: italic;">y</span> := $(<span style="color: #ffd700; font-style: italic;">x</span>) bar
<span style="color: #ffd700; font-style: italic;">x</span> := later
</pre>


<p>
其等价于:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">y</span> := foo bar
<span style="color: #ffd700; font-style: italic;">x</span> := later
</pre>


<p>
值得一提的是，这种方法， <b>前面的变量不能使用后面的变量</b> ，只能使用前面已定义好了的变量。如果是这样:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">y</span> := $(<span style="color: #ffd700; font-style: italic;">x</span>) bar
<span style="color: #ffd700; font-style: italic;">x</span> := foo
</pre>

<p>
那么，y 的值是“bar”，而不是“foo bar”。上面都是一些比较简单的变量使用了，让我们来看一个复杂的例子，其中包括了 make的函数、条件表达式和一个系统变量“MAKELEVEL”的使用:
</p>



<pre class="src src-makefile">ifeq (0,${<span style="color: #ffd700; font-style: italic;">MAKELEVEL</span>})
<span style="color: #ffd700; font-style: italic;">cur-dir</span> := $(<span style="color: #ffd700; font-style: italic;">shell</span> pwd)
<span style="color: #ffd700; font-style: italic;">whoami</span> := $(<span style="color: #ffd700; font-style: italic;">shell</span> whoami)
<span style="color: #ffd700; font-style: italic;">host-type</span> := $(<span style="color: #ffd700; font-style: italic;">shell</span> arch)
<span style="color: #ffd700; font-style: italic;">MAKE</span> := ${<span style="color: #ffd700; font-style: italic;">MAKE</span>} host-type=${<span style="color: #ffd700; font-style: italic;">host-type</span>} whoami=${<span style="color: #ffd700; font-style: italic;">whoami</span>}
endif
</pre>


<p>
关于条件表达式和函数，我们在后面再说，对于系统变量“MAKELEVEL”，其意思是， 如果我们的 make 有一个嵌套执行的动作(参见前面的“<a href="#sec-5-4">嵌套执行 make</a>”)，那么，这个变量会 <b>记录我们的当前 Makefile 的调用层数</b> 。
</p>
<p>
下面再介绍两个定义变量时我们需要知道的，请先看一个例子，如果我们要定义一个变量，其值是一个空格，那么我们可以这样来:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">nullstring</span> :=
<span style="color: #ffd700; font-style: italic;">space</span> := $(<span style="color: #ffd700; font-style: italic;">nullstring</span>) <span style="color: #ffd700;"># </span><span style="color: #ffd700;">end of the line</span>
</pre>


<p>
nullstring 是一个 Empty 变量，其中什么也没有，而我们的 space 的值是一个空格。因为在操作符的右边是很难描述一个空格的，这里采用的技术很管用，先用一个 Empty 变量来标明变量的值开始了，而后面采用“#”注释符来表示变量定义的终止，这样，我们可以定义出其值是一个空格的变量。请注意这里关于“#”的使用，注释符“#”的这种特性值得我们注意，如果我们这样定义一个变量:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">dir</span> := /foo/bar <span style="color: #ffd700;"># </span><span style="color: #ffd700;">directory to put the frobs in</span>
</pre>


<p>
dir 这个变量的值是“/foo/bar”，后面还跟了 4 个空格，如果我们这样使用这样变量来指定别的目录——“$(dir)/file”那么就完蛋了。
</p>
<p>
还有一个比较有用的操作符是“?=”，先看示例:FOO ?= bar其含义是，如果 FOO 没有被定义过，那么变量 FOO 的值就是“bar”，如果 FOO 先前被定义过，那么这条语将什么也不做，其等价于:
</p>



<pre class="src src-makefile">ifeq ($(<span style="color: #ffd700; font-style: italic;">origin</span> FOO), undefined)
<span style="color: #ffd700; font-style: italic;">FOO</span> = bar
endif
</pre>


</div>

</div>

<div id="outline-container-6-3" class="outline-3">
<h3 id="sec-6-3"><span class="section-number-3">6.3</span> 变量高级用法</h3>
<div class="outline-text-3" id="text-6-3">


<p>
   这里介绍两种变量的高级使用方法:
</p>

</div>

<div id="outline-container-6-3-1" class="outline-4">
<h4 id="sec-6-3-1"><span class="section-number-4">6.3.1</span> 变量值的替换</h4>
<div class="outline-text-4" id="text-6-3-1">


<p>    
    第一种是变量值的替换。我们可以替换变量中的共有的部分，其格式是“$(var:a=b)”或是“${var:a=b}”，其意思是，把变量“var”中所有以“a”字串“结尾”的“a”替换成“b”字串。这里的“结尾”意思是“空格”或是“结束符”。
</p>
<p>
    还是看一个示例吧:
</p>


<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">foo</span> := a.o b.o c.o
<span style="color: #ffd700; font-style: italic;">bar</span> := $(<span style="color: #ffd700; font-style: italic;">foo</span>:<span style="color: #ffd700; font-style: italic;">.o</span>=.c)
</pre>


<p>    
这个示例中，我们先定义了一个“$(foo)”变量，而第二行的意思是把“$(foo)”中所有以“.o”字串“结尾”全部替换成“.c”，所以我们的“$(bar)”的值就是“a.c b.c c.c”。另外一种变量替换的技术是以“静态模式”(参见<a href="#sec-4-7">静态模式</a>)定义的，如:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">foo</span> := a.o b.o c.o
<span style="color: #ffd700; font-style: italic;">bar</span> := $(<span style="color: #ffd700; font-style: italic;">foo</span>:<span style="color: #ffd700; font-style: italic;">%.o</span>=%.c)
</pre>


<p>
这依赖于被替换字串中的有相同的模式，模式中必须包含一个“%”字符，这个例子同样让$(bar)变量的值为“a.c b.c c.c”。
</p>
</div>

</div>

<div id="outline-container-6-3-2" class="outline-4">
<h4 id="sec-6-3-2"><span class="section-number-4">6.3.2</span> 把变量的值再当成变量</h4>
<div class="outline-text-4" id="text-6-3-2">


<p>
    先看一个例子:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">x</span> = y
<span style="color: #ffd700; font-style: italic;">y</span> = z
<span style="color: #ffd700; font-style: italic;">a</span> := $($(<span style="color: #ffd700; font-style: italic;">x</span>))
</pre>


<p>    
在这个例子中，$(x)的值是“y”，所以$($(x))就是$(y)，于是$(a)的值就是“z”。(注意，是“x=y”，而不是“x=$(y)”)
</p>
<p>
我们还可以使用更多的层次:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">x</span> = y
<span style="color: #ffd700; font-style: italic;">y</span> = z
<span style="color: #ffd700; font-style: italic;">z</span> = u
<span style="color: #ffd700; font-style: italic;">a</span> := $($($(<span style="color: #ffd700; font-style: italic;">x</span>)))
</pre>


<p>
这里的$(a)的值是“u”，相关的推导留给读者自己去做吧。
</p>
<p>
让我们再复杂一点，使用上“在变量定义中使用变量”的第一个方式，来看一个例子:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">x</span> = $(<span style="color: #ffd700; font-style: italic;">y</span>)
<span style="color: #ffd700; font-style: italic;">y</span> = z
<span style="color: #ffd700; font-style: italic;">z</span> = Hello
<span style="color: #ffd700; font-style: italic;">a</span> := $($(<span style="color: #ffd700; font-style: italic;">x</span>))
</pre>


<p>
这里的$($(x))被替换成了$($(y))，因为$(y)值是“z”，所以，最终结果是:a:=$(z)，也就是“Hello”。
</p>
<p>
再复杂一点，我们再加上函数:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">x</span> = variable1
<span style="color: #ffd700; font-style: italic;">variable2</span> := Hello
<span style="color: #ffd700; font-style: italic;">y</span> = $(<span style="color: #ffd700; font-style: italic;">subst</span> 1,2,$(<span style="color: #ffd700; font-style: italic;">x</span>))
<span style="color: #ffd700; font-style: italic;">z</span> = y
<span style="color: #ffd700; font-style: italic;">a</span> := $($($(<span style="color: #ffd700; font-style: italic;">z</span>)))
</pre>


<p>
这个例子中，“$($($(z)))”扩展为“$($(y))”，而其再次被扩展为“$($(subst 1,2,$(x)))”。$(x)的值是“variable1”，subst 函数把“variable1”中的所有“1”字串替换成“2”字串，于是，“variable1”变成“variable2”，再取其值，所以，最终，$(a)的值就是$(variable2)的值——“Hello”。(喔，好不容易)
</p>
<p>
在这种方式中，或要可以使用多个变量来组成一个变量的名字，然后再取其值:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">first_second</span> = Hello
<span style="color: #ffd700; font-style: italic;">a</span> = first
<span style="color: #ffd700; font-style: italic;">b</span> = second
<span style="color: #ffd700; font-style: italic;">all</span> = $($<span style="color: #b0c4de; font-weight: bold;">a</span>_$<span style="color: #b0c4de; font-weight: bold;">b</span>)
</pre>


<p>
这里的“$a_$b”组成了“first<sub>second”，于是，</sub>$(all)的值就是“Hello”。再来看看结合第一种技术的例子:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">a_objects</span> := a.o b.o c.o
<span style="color: #ffd700; font-style: italic;">1_objects</span> := 1.o 2.o 3.o
<span style="color: #ffd700; font-style: italic;">sources</span> := $($(<span style="color: #ffd700; font-style: italic;">a1</span>)_objects:<span style="color: #ffd700; font-style: italic;">.o</span>=.c)
</pre>


<p>
这个例子中，如果$(a1)的值是“a”的话，那么，$(sources)的值就是“a.c b.c c.c”;如果$(a1)的值是“1”，那么$(sources)的值是“1.c 2.c 3.c”。
</p>
<p>
再来看一个这种技术和“函数”与“条件语句”一同使用的例子:
</p>



<pre class="src src-makefile">ifdef do_sort
<span style="color: #ffd700; font-style: italic;">func</span> := sort
else
<span style="color: #ffd700; font-style: italic;">func</span> := strip
endif
<span style="color: #ffd700; font-style: italic;">bar</span> := a d b g q c
<span style="color: #ffd700; font-style: italic;">foo</span> := $($(<span style="color: #ffd700; font-style: italic;">func</span>) $(<span style="color: #ffd700; font-style: italic;">bar</span>))
</pre>


<p>
这个示例中，如果定义了“do<sub>sort”，那么</sub>:foo := $(sort a d b g q c)，于是$(foo)的值就是“a b c d g q”，而如果没有定义“do<sub>sort”，那么</sub>:foo := $(sort a d bg q c)，调用的就是 strip 函数。当然，“把变量的值再当成变量”这种技术，同样可以用在操作符的左边:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">dir</span> = foo
<span style="color: #ffd700; font-style: italic;">$(</span><span style="color: #ffd700; font-style: italic;">dir</span><span style="color: #ffd700; font-style: italic;">)_sources</span> := $(<span style="color: #ffd700; font-style: italic;">wildcard</span> $(<span style="color: #ffd700; font-style: italic;">dir</span>)/*.c)
define $(<span style="color: #ffd700; font-style: italic;">dir</span>)_print
lpr $($(<span style="color: #ffd700; font-style: italic;">dir</span>)_sources)
endef
</pre>

<p>
这个例子中定义了三个变量:“dir”，“foo<sub>sources”和“foo</sub><sub>print”。</sub>
</p>
</div>
</div>

</div>

<div id="outline-container-6-4" class="outline-3">
<h3 id="sec-6-4"><span class="section-number-3">6.4</span> 追加变量值</h3>
<div class="outline-text-3" id="text-6-4">


<p>
   我们可以使用 <code>+=</code> 操作符给变量追加值，如:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">objects</span> = main.o foo.o bar.o utils.o
<span style="color: #ffd700; font-style: italic;">objects</span> += another.o
</pre>


<p>
   于是，我们的$(objects)值变成:“main.o foo.o bar.o utils.o another.o”(another.o被追加进去了)
</p>
<p>
   使用“+=”操作符，可以模拟为下面的这种例子:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">objects</span> = main.o foo.o bar.o utils.o
<span style="color: #ffd700; font-style: italic;">objects</span> := $(<span style="color: #ffd700; font-style: italic;">objects</span>) another.o
</pre>


<p>
   所不同的是，用“+=”更为简洁。如果变量之前没有定义过，那么，“+=”会自动变成“=”，如果前面有变量定义，那么“+=”会继承于前次操作的赋值符。如果前一次的是“:=”，那么“+=”会以“:=”作为其赋值符，如:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">variable</span> := value
<span style="color: #ffd700; font-style: italic;">variable</span> += more
</pre>


<p>
等价于:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">variable</span> := value
<span style="color: #ffd700; font-style: italic;">variable</span> := $(<span style="color: #ffd700; font-style: italic;">variable</span>) more
</pre>


<p>
但如果是这种情况:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">variable</span> = value
<span style="color: #ffd700; font-style: italic;">variable</span> += more
</pre>


<p>
由于前次的赋值符是“=”，所以“+=”也会以“=”来做为赋值，那么岂不会发生变量的递补归定义，这是很不好的，所以 make 会自动为我们解决这个问题，我们不必担心这个问题。
</p>
</div>

</div>

<div id="outline-container-6-5" class="outline-3">
<h3 id="sec-6-5"><span class="section-number-3">6.5</span> override 指示符</h3>
<div class="outline-text-3" id="text-6-5">

<p>    如果有变量是通过 make 的命令行参数设置的，那么 Makefile 中对这个变量的赋值会被忽略。如果你想在 Makefile 中设置这类参数的值，那么，你可以使用 <code>override</code> 指示符。其语法是:
</p>



<pre class="src src-makefile">override <span style="color: #ffd700; font-style: italic;">&lt;variable&gt;</span> = &lt;value&gt;
override <span style="color: #ffd700; font-style: italic;">&lt;variable&gt;</span> := &lt;value&gt;
</pre>


<p>   
当然，你还可以追加:
</p>



<pre class="src src-makefile">override <span style="color: #ffd700; font-style: italic;">&lt;variable&gt;</span> += &lt;more text&gt;
</pre>


<p>
对于多行的变量定义，我们用 define 指示符，在 define 指示符前，也同样可以使用 override指示符，如:
</p>



<pre class="src src-makefile">override define foo
bar
endef
</pre>


</div>

</div>

<div id="outline-container-6-6" class="outline-3">
<h3 id="sec-6-6"><span class="section-number-3">6.6</span> 多行变量</h3>
<div class="outline-text-3" id="text-6-6">


<p>
   还有一种设置变量值的方法是使用 define 关键字。使用 define 关键字设置变量的值可以有换行，这有利于定义一系列的命令(前面我们讲过“命令包”的技术就是利用这个关键字)。
</p>
<p>
   <b>define 指示符后面跟的是变量的名字，而重起一行定义变量的值</b> ，定义是以 endef 关键字结束。其工作方式和“=”操作符一样。变量的值可以包含函数、命令、文字，或是其它变量。因为命令需要以[Tab]键开头，所以如果你用 define 定义的命令变量中没有以[Tab]键开头，那么 make 就不会把其认为是命令。
</p>
<p>
   下面的这个示例展示了 define 的用法:
</p>



<pre class="src src-makefile">define two-lines
echo foo
echo $(<span style="color: #ffd700; font-style: italic;">bar</span>)
endef
</pre>


</div>

</div>

<div id="outline-container-6-7" class="outline-3">
<h3 id="sec-6-7"><span class="section-number-3">6.7</span> 环境变量</h3>
<div class="outline-text-3" id="text-6-7">


<p>
   make 运行时的系统环境变量可以在 make 开始运行时被载入到 Makefile 文件中，但是如果 Makefile 中已定义了这个变量，或是这个变量由 make 命令行带入，那么系统的环境变量的值将被覆盖。(如果 make 指定了“-e”参数，那么，系统环境变量将覆盖 Makefile 中定义的变量)
</p>
<p>
   因此，如果我们在环境变量中设置了 <b>“CFLAGS”环境变量</b> ，那么我们就可以在所有的Makefile 中使用这个变量了。这对于我们 <b>使用统一的编译参数</b> 有比较大的好处。如果Makefile 中定义了 CFLAGS，那么则会使用 Makefile 中的这个变量，如果没有定义则使用系统环境变量的值，一个共性和个性的统一，很像“全局变量”和“局部变量”的特性。
</p>
<p>
   当 make <a href="#sec-5-4">嵌套执行</a>时，上层 Makefile 中定义的变量会以系统环境变量的方式传递到下层的 Makefile 中。当然，默认情况下，只有通过命令行设置的变量会被传递。而定义在文件中的变量，如果要向下层 Makefile 传递，则需要使用 <a href="#sec-5-4-1">export</a> 关键字来声明。
</p>
<p>
   当然，我并不推荐把许多的变量都定义在系统环境中，这样，在我们执行不用的Makefile 时，拥有的是同一套系统变量，这可能会带来更多的麻烦。
</p>
</div>

</div>

<div id="outline-container-6-8" class="outline-3">
<h3 id="sec-6-8"><span class="section-number-3">6.8</span> 目标变量</h3>
<div class="outline-text-3" id="text-6-8">


<p>
   前面我们所讲的在 Makefile 中定义的变量都是“全局变量”，在整个文件，我们都可以访问这些变量。当然，“自动化变量”除外，如“$&lt;”等这种类量的自动化变量就属于“规则型变量”，这种变量的值依赖于规则的目标和依赖目标的定义。当然，我样同样可以为某个目标设置局部变量，这种变量被称为“Target-specific Variable”，它可以和“全局变量”同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。而不会影响规则链以外的全局变量的值。
</p>
<p>
   其语法是:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">&lt;target ...&gt;</span> : &lt;variable-assignment&gt;
<span style="color: #ffd700; font-weight: bold;">&lt;target ...&gt;</span> : override &lt;variable-assignment&gt;
</pre>


<p>
   &lt;variable-assignment&gt;可以是前面讲过的各种赋值表达式，如“=”、“:=”、“+=”或是“?=”。第二个语法是针对于 make 命令行带入的变量，或是系统环境变量。这个特性非常的有用，当我们设置了这样一个变量，这个变量会作用到由这个目标所引发的所有的规则中去。如:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">prog</span> : <span style="color: #ffd700; font-style: italic;">CFLAGS</span> = -g
<span style="color: #ffd700; font-weight: bold;">prog</span> : prog.o foo.o bar.o
        $(<span style="color: #ffd700; font-style: italic;">CC</span>) $(<span style="color: #ffd700; font-style: italic;">CFLAGS</span>) prog.o foo.o bar.o

<span style="color: #ffd700; font-weight: bold;">prog.o</span> : prog.c
        $(<span style="color: #ffd700; font-style: italic;">CC</span>) $(<span style="color: #ffd700; font-style: italic;">CFLAGS</span>) prog.c

<span style="color: #ffd700; font-weight: bold;">foo.o</span> : foo.c
        $(<span style="color: #ffd700; font-style: italic;">CC</span>) $(<span style="color: #ffd700; font-style: italic;">CFLAGS</span>) foo.c

<span style="color: #ffd700; font-weight: bold;">bar.o</span> : bar.c
        $(<span style="color: #ffd700; font-style: italic;">CC</span>) $(<span style="color: #ffd700; font-style: italic;">CFLAGS</span>) bar.c
</pre>


<p>
    在这个示例中，不管全局的$(CFLAGS)的值是什么，在 prog 目标，以及其所引发的所有规则中(prog.o foo.o bar.o 的规则)，$(CFLAGS)的值都是“-g”。
</p>
</div>

</div>

<div id="outline-container-6-9" class="outline-3">
<h3 id="sec-6-9"><span class="section-number-3">6.9</span> 模式变量</h3>
<div class="outline-text-3" id="text-6-9">


<p>
   在 GNU 的 make 中，还支持模式变量(Pattern-specific Variable)，通过上面的目标变量中，我们知道，变量可以定义在某个目标上。模式变量的好处就是，我们可以给定一种“模式”，可以把变量定义在符合这种模式的所有目标上。
</p>
<p>
   我们知道，make 的“模式”一般是至少含有一个“%”的，所以，我们可以以如下方式给所有以[.o]结尾的目标定义目标变量:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">%.o</span> : <span style="color: #ffd700; font-style: italic;">CFLAGS</span> = -O
</pre>


<p>
   同样，模式变量的语法和“目标变量”一样:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">&lt;pattern ...&gt;</span> : &lt;variable-assignment&gt;

<span style="color: #ffd700; font-weight: bold;">&lt;pattern ...&gt;</span> : override &lt;variable-assignment&gt;
</pre>


<p>
   override 同样是针对于系统环境传入的变量，或是 make 命令行指定的变量。
</p>
</div>
</div>

</div>

<div id="outline-container-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> 使用条件判断</h2>
<div class="outline-text-2" id="text-7">


<p>
  使用条件判断，可以让 make 根据运行时的不同情况选择不同的执行分支。条件表达式可以是比较变量的值，或是比较变量和常量的值。
</p>

</div>

<div id="outline-container-7-1" class="outline-3">
<h3 id="sec-7-1"><span class="section-number-3">7.1</span> 示例</h3>
<div class="outline-text-3" id="text-7-1">


<p>
   下面的例子，判断$(CC)变量是否“gcc”，如果是的话，则使用 GNU 函数编译目标。
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">libs_for_gcc</span> = -lgnu
<span style="color: #ffd700; font-style: italic;">normal_libs</span> =
<span style="color: #ffd700; font-weight: bold;">foo</span>: $(<span style="color: #ffd700; font-style: italic;">objects</span>)
ifeq ($(<span style="color: #ffd700; font-style: italic;">CC</span>),gcc)
        $(<span style="color: #ffd700; font-style: italic;">CC</span>) -o foo $(<span style="color: #ffd700; font-style: italic;">objects</span>) $(<span style="color: #ffd700; font-style: italic;">libs_for_gcc</span>)
else
        $(<span style="color: #ffd700; font-style: italic;">CC</span>) -o foo $(<span style="color: #ffd700; font-style: italic;">objects</span>) $(<span style="color: #ffd700; font-style: italic;">normal_libs</span>)
endif   
</pre>


<p>
   可见，在上面示例的这个规则中，目标“foo”可以根据变量“$(CC)”值来选取不同的函数库来编译程序。
</p>
<p>
   我们可以从上面的示例中看到三个关键字:ifeq、else 和 endif。ifeq 的意思表示条件语句的开始，并指定一个条件表达式，表达式包含两个参数，以逗号分隔，表达式以圆括号括起。else 表示条件表达式为假的情况。endif 表示一个条件语句的结束，任何一个条件表达式都应该以 endif 结束。
</p>
<p>
   当我们的变量$(CC)值是“gcc”时，目标 foo 的规则是:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">foo</span>: $(<span style="color: #ffd700; font-style: italic;">objects</span>)
        $(<span style="color: #ffd700; font-style: italic;">CC</span>) -o foo $(<span style="color: #ffd700; font-style: italic;">objects</span>) $(<span style="color: #ffd700; font-style: italic;">libs_for_gcc</span>)
</pre>


<p>
   而当我们的变量$(CC)值不是“gcc”时(比如“cc”)，目标 foo 的规则是:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">foo</span>: $(<span style="color: #ffd700; font-style: italic;">objects</span>)
        $(<span style="color: #ffd700; font-style: italic;">CC</span>) -o foo $(<span style="color: #ffd700; font-style: italic;">objects</span>) $(<span style="color: #ffd700; font-style: italic;">normal_libs</span>)
</pre>


<p>
   当然，我们还可以把上面的那个例子写得更简洁一些:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">libs_for_gcc</span> = -lgnu
<span style="color: #ffd700; font-style: italic;">normal_libs</span> =
ifeq ($(<span style="color: #ffd700; font-style: italic;">CC</span>),gcc)
<span style="color: #ffd700; font-style: italic;">libs</span>=$(<span style="color: #ffd700; font-style: italic;">libs_for_gcc</span>)
else
<span style="color: #ffd700; font-style: italic;">libs</span>=$(<span style="color: #ffd700; font-style: italic;">normal_libs</span>)
endif
<span style="color: #ffd700; font-weight: bold;">foo</span>: $(<span style="color: #ffd700; font-style: italic;">objects</span>)
        $(<span style="color: #ffd700; font-style: italic;">CC</span>) -o foo $(<span style="color: #ffd700; font-style: italic;">objects</span>) $(<span style="color: #ffd700; font-style: italic;">libs</span>)
</pre>


</div>

</div>

<div id="outline-container-7-2" class="outline-3">
<h3 id="sec-7-2"><span class="section-number-3">7.2</span> 语法</h3>
<div class="outline-text-3" id="text-7-2">


<p>
   条件表达式的语法为:
</p>



<pre class="src src-makefile">&lt;conditional-directive&gt;
&lt;text-if-true&gt;
endif
</pre>


<p>
以及:
</p>



<pre class="src src-makefile">&lt;conditional-directive&gt;
&lt;text-if-true&gt;
else
&lt;text-if-false&gt;
endif
</pre>


<p>
其中&lt;conditional-directive&gt;表示条件关键字，如“ifeq”。这个关键字有四个：
</p>
<ul>
<li><a name="ifeq" class="target">ifeq</a> : 比较两个参数是否相同
</li>
</ul>




<pre class="src src-makefile">ifeq (&lt;arg1&gt;, &lt;arg2&gt;)
ifeq <span style="color: #f0e68c;">'&lt;arg1&gt;'</span> <span style="color: #f0e68c;">'&lt;arg2&gt;'</span>
ifeq <span style="color: #f0e68c;">"&lt;arg1&gt;"</span> <span style="color: #f0e68c;">"&lt;arg2&gt;"</span>
ifeq <span style="color: #f0e68c;">"&lt;arg1&gt;"</span> <span style="color: #f0e68c;">'&lt;arg2&gt;'</span>
ifeq <span style="color: #f0e68c;">'&lt;arg1&gt;'</span> <span style="color: #f0e68c;">"&lt;arg2&gt;"</span>
</pre>


<p>
比较参数“arg1”和“arg2”的值是否相同。当然，参数中我们还可以使用 make 的函数。
</p>
<p>
如:
</p>



<pre class="src src-makefile">ifeq ($(<span style="color: #ffd700; font-style: italic;">strip</span> $(<span style="color: #ffd700; font-style: italic;">foo</span>)),)
&lt;text-if-empty&gt;
endif
</pre>


<ul>
<li>ifneq: 比较两个参数是否不同
</li>
</ul>




<pre class="src src-makefile">ifneq (&lt;arg1&gt;, &lt;arg2&gt;)
ifneq <span style="color: #f0e68c;">'&lt;arg1&gt;'</span> <span style="color: #f0e68c;">'&lt;arg2&gt;'</span>
ifneq <span style="color: #f0e68c;">"&lt;arg1&gt;"</span> <span style="color: #f0e68c;">"&lt;arg2&gt;"</span>
ifneq <span style="color: #f0e68c;">"&lt;arg1&gt;"</span> <span style="color: #f0e68c;">'&lt;arg2&gt;'</span>
ifneq <span style="color: #f0e68c;">'&lt;arg1&gt;'</span> <span style="color: #f0e68c;">"&lt;arg2&gt;"</span>
</pre>


<p>
其比较参数“arg1”和“arg2”的值是否相同，如果不同，则为真。和“ifeq”类似。
</p>
<ul>
<li>ifdef: 是测试一个变量 <b>是否有值</b>
</li>
</ul>




<pre class="src src-makefile">ifdef &lt;variable-name&gt;
</pre>


<p>
如果变量&lt;variable-name&gt;的值 <b>非空</b> ，那么表达式为真。否则，表达式为假。当然，&lt;variable-name&gt;同样可以是一个函数的返回值。注意，ifdef 只是测试一个变量 <b>是否有值</b> ，其并不会把变量扩展到当前位置。还是来看两个例子:
</p>
<p>
示例一:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">bar</span> =
<span style="color: #ffd700; font-style: italic;">foo</span> = $(<span style="color: #ffd700; font-style: italic;">bar</span>)
ifdef foo
<span style="color: #ffd700; font-style: italic;">frobozz</span> = yes
else
<span style="color: #ffd700; font-style: italic;">frobozz</span> = no
endif
</pre>


<p>
示例二:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">foo</span> =
ifdef foo
<span style="color: #ffd700; font-style: italic;">frobozz</span> = yes
else
<span style="color: #ffd700; font-style: italic;">frobozz</span> = no
endif
</pre>


<p>
第一个例子中，“$(frobozz)”值是“yes”，第二个则是“no”。
</p>
<ul>
<li>ifndef：测试一个变量是否为空。
</li>
</ul>




<pre class="src src-makefile">ifndef &lt;variable-name&gt;
</pre>


</div>
</div>

</div>

<div id="outline-container-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> 使用 <span class="target">函数</span></h2>
<div class="outline-text-2" id="text-8">



</div>

<div id="outline-container-8-1" class="outline-3">
<h3 id="sec-8-1"><span class="section-number-3">8.1</span> 函数的调用语法</h3>
<div class="outline-text-3" id="text-8-1">


<p>
   函数调用，很像变量的使用，也是以“$”来标识的，其语法如下:
</p>



<pre class="src src-makefile">$(&lt;function&gt; &lt;arguments&gt;)
</pre>


<p>
或是
</p>



<pre class="src src-makefile">${&lt;function&gt; &lt;arguments&gt;}
</pre>


<p>   
这里，&lt;function&gt;就是函数名，make 支持的函数不多。&lt;arguments&gt;是函数的参数，参数间以逗号“，”分隔，而函数名和参数之间以“空格”分隔。函数调用以 <b>“$”</b> 开头，以 <b>圆括号或花括号</b> 把函数名和参数括起。感觉很像一个变量，是不是?函数中的参数可以使用变量，为了风格的统一，函数和变量的括号最好一样，如使用 <code>$(subst a,b,$(x))</code> 这样的形式，而不是 <code>$(subst a,b,${x})</code> 的形式。因为统一会更清楚，也会减少一些不必要的麻烦。
</p>
<p>
还是来看一个示例:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">comma</span>:= ,
<span style="color: #ffd700; font-style: italic;">empty</span>:=
<span style="color: #ffd700; font-style: italic;">space</span>:= $(<span style="color: #ffd700; font-style: italic;">empty</span>) $(<span style="color: #ffd700; font-style: italic;">empty</span>)
<span style="color: #ffd700; font-style: italic;">foo</span>:= a b c
<span style="color: #ffd700; font-style: italic;">bar</span>:= $(<span style="color: #ffd700; font-style: italic;">subst</span> $(<span style="color: #ffd700; font-style: italic;">space</span>),$(<span style="color: #ffd700; font-style: italic;">comma</span>),$(<span style="color: #ffd700; font-style: italic;">foo</span>))
</pre>


<p>
在这个示例中，$(comma)的值是一个逗号。$(space)使用了$(empty)定义了一个空格，$(foo)的值是“a b c”，$(bar)的定义用，调用了函数“subst”，这是一个替换函数，这个函数有三个参数，第一个参数是被替换字串，第二个参数是替换字串，第三个参数是替换操作作用的字串。这个函数也就是把$(foo)中的空格替换成逗号，所以$(bar)的值是“a,b,c”。
</p>
</div>

</div>

<div id="outline-container-8-2" class="outline-3">
<h3 id="sec-8-2"><span class="section-number-3">8.2</span> 字符串处理函数</h3>
<div class="outline-text-3" id="text-8-2">



</div>

<div id="outline-container-8-2-1" class="outline-4">
<h4 id="sec-8-2-1"><span class="section-number-4">8.2.1</span> subst</h4>
<div class="outline-text-4" id="text-8-2-1">





<pre class="src src-makefile">$(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt;)
</pre>

<ul>
<li>名称:字符串替换函数——subst。
</li>
<li>功能:把字串&lt;text&gt;中的&lt;from&gt;字符串替换成&lt;to&gt;。
</li>
<li>返回:函数返回被替换过后的字符串。
</li>
<li>示例: <code>$(subst ee,EE,feet on the street)</code> 把“feet on the street”中的“ee”替换成“EE”，返回结果是“fEEt on the strEEt”。
</li>
</ul>


</div>

</div>

<div id="outline-container-8-2-2" class="outline-4">
<h4 id="sec-8-2-2"><span class="section-number-4">8.2.2</span> patsubst</h4>
<div class="outline-text-4" id="text-8-2-2">




<pre class="src src-makefile">$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)
</pre>

<ul>
<li>名称:模式字符串替换函数——patsubst。
</li>
<li>功能:查找&lt;text&gt;中的单词(单词以“空格”、“Tab”或“回车”“换行”分隔)是否符合模式&lt;pattern&gt;，如果匹配的话，则以&lt;replacement&gt;替换。这里，&lt;pattern&gt;可以包括通配符“%”，表示任意长度的字串。如果&lt;replacement&gt;中也包含“%”，那么，&lt;replacement&gt;中的这个“%”将是&lt;pattern&gt;中的那个“%”所代表的字串。(可以用“\”来转义，以“\%”来表示真实含义的“%”字符)
</li>
<li>返回:函数返回被替换过后的字符串。  
</li>
<li>示例: <code>$(patsubst %.c,%.o,x.c.c bar.c)</code>  把字串“x.c.c bar.c”符合模式[%.c]的单词替换成[%.o]，返回结果是“x.c.o bar.o”    
</li>
<li>备注: 这和我们前面“变量章节”说过的相关知识有点相似。

<p>  
  如:
</p>
<p>  
  <code>$(var:&lt;pattern&gt;=&lt;replacement&gt;)</code>  相当于  <code>$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,$(var))</code>
</p>
<p>
  而 <code>$(var: &lt;suffix&gt;=&lt;replacement&gt;)</code>  则相当于 <code>$(patsubst %&lt;suffix&gt;,%&lt;replacement&gt;,$(var))</code> 。
</p>
<p>  
  例如有: <code>objects = foo.o bar.o baz.o</code>
</p>
<p>  
  那么， <code>$(objects:.o</code>.c)= 和 <code>$(patsubst %.o,%.c,$(objects))</code> 是一样的。
</p></li>
</ul>


</div>

</div>

<div id="outline-container-8-2-3" class="outline-4">
<h4 id="sec-8-2-3"><span class="section-number-4">8.2.3</span> strip</h4>
<div class="outline-text-4" id="text-8-2-3">




<pre class="src src-makefile">$(strip &lt;string&gt;)
</pre>

<ul>
<li>名称:去空格函数——strip。
</li>
<li>功能:去掉&lt;string&gt;字串中开头和结尾的空字符。
</li>
<li>返回:返回被去掉空格的字符串值。  
</li>
<li>示例： <code>$(strip a b c )</code>  把字串“a b c ”去到开头和结尾的空格，结果是“a b c”。
</li>
</ul>


</div>

</div>

<div id="outline-container-8-2-4" class="outline-4">
<h4 id="sec-8-2-4"><span class="section-number-4">8.2.4</span> findstring</h4>
<div class="outline-text-4" id="text-8-2-4">




<pre class="src src-makefile">$(findstring &lt;find&gt;,&lt;in&gt;)
</pre>

<ul>
<li>名称:查找字符串函数——findstring。
</li>
<li>功能:在字串&lt;in&gt;中查找&lt;find&gt;字串。
</li>
<li>返回:如果找到，那么返回&lt;find&gt;，否则返回空字符串。
</li>
<li>示例:



<pre class="src src-makefile">$(findstring a,a b c)
$(<span style="color: #ffd700; font-style: italic;">findstring</span> a,b c)
</pre>

<p>
    第一个函数返回“a”字符串，第二个返回“”字符串(空字符串)
</p></li>
</ul>

</div>

</div>

<div id="outline-container-8-2-5" class="outline-4">
<h4 id="sec-8-2-5"><span class="section-number-4">8.2.5</span> filter</h4>
<div class="outline-text-4" id="text-8-2-5">




<pre class="src src-makefile">$(filter &lt;pattern...&gt;,&lt;text&gt;)
</pre>

<ul>
<li>名称:过滤函数——filter。
</li>
<li>功能:以&lt;pattern&gt;模式过滤&lt;text&gt;字符串中的单词， <b>保留</b> 符合模式&lt;pattern&gt;的单词。可以有多个模式。
</li>
<li>返回:返回符合模式&lt;pattern&gt;的字串。
</li>
<li>示例:



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">sources</span> := foo.c bar.c baz.s ugh.h
<span style="color: #ffd700; font-weight: bold;">foo</span>: $(<span style="color: #ffd700; font-style: italic;">sources</span>)
        cc $(<span style="color: #ffd700; font-style: italic;">filter</span> %.c %.s,$(<span style="color: #ffd700; font-style: italic;">sources</span>)) -o foo
</pre>

<p>
    <code>$(filter %.c %.s,$(sources))</code> 返回的值是“foo.c bar.c baz.s”。  
</p></li>
</ul>


</div>

</div>

<div id="outline-container-8-2-6" class="outline-4">
<h4 id="sec-8-2-6"><span class="section-number-4">8.2.6</span> filter-out</h4>
<div class="outline-text-4" id="text-8-2-6">




<pre class="src src-makefile">$(filter-out &lt;pattern...&gt;,&lt;text&gt;)
</pre>

<ul>
<li>名称:反过滤函数——filter-out。
</li>
<li>功能:以&lt;pattern&gt;模式过滤&lt;text&gt;字符串中的单词，去除符合模式&lt;pattern&gt;的单词。可以有多个模式。
</li>
<li>返回:返回不符合模式&lt;pattern&gt;的字串。
</li>
<li>示例:



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">objects</span>=main1.o foo.o main2.o bar.o
<span style="color: #ffd700; font-style: italic;">mains</span>=main1.o main2.o
</pre>

<p>
  <code>$(filter-out $(mains),$(objects))</code> 返回值是“foo.o bar.o”。    
</p></li>
</ul>


</div>

</div>

<div id="outline-container-8-2-7" class="outline-4">
<h4 id="sec-8-2-7"><span class="section-number-4">8.2.7</span> sort</h4>
<div class="outline-text-4" id="text-8-2-7">




<pre class="src src-makefile">$(sort &lt;list&gt;)
</pre>

<ul>
<li>名称:排序函数——sort。
</li>
<li>功能:给字符串&lt;list&gt;中的单词排序(升序)。
</li>
<li>返回:返回排序后的字符串。
</li>
<li>示例: <code>$(sort foo bar lose)</code>  返回“bar foo lose”。
</li>
<li>备注:sort 函数会去掉&lt;list&gt;中相同的单词。    
</li>
</ul>


</div>

</div>

<div id="outline-container-8-2-8" class="outline-4">
<h4 id="sec-8-2-8"><span class="section-number-4">8.2.8</span> word</h4>
<div class="outline-text-4" id="text-8-2-8">




<pre class="src src-makefile">$(word &lt;n&gt;,&lt;text&gt;)
</pre>

<ul>
<li>名称:取单词函数——word。
</li>
<li>功能:取字符串&lt;text&gt;中第&lt;n&gt;个单词。(从一开始)
</li>
<li>返回:返回字符串&lt;text&gt;中第&lt;n&gt;个单词。如果&lt;n&gt;比&lt;text&gt;中的单词数要大，那么返回空字符串。
</li>
<li>示例: <code>$(word 2, foo bar baz)</code>  返回值是“bar”。    
</li>
</ul>


</div>

</div>

<div id="outline-container-8-2-9" class="outline-4">
<h4 id="sec-8-2-9"><span class="section-number-4">8.2.9</span> wordlist</h4>
<div class="outline-text-4" id="text-8-2-9">




<pre class="src src-makefile">$(wordlist &lt;s&gt;,&lt;e&gt;,&lt;text&gt;)
</pre>

<ul>
<li>名称:取单词串函数——wordlist。
</li>
<li>功能:从字符串&lt;text&gt;中取从&lt;s&gt;开始到&lt;e&gt;的单词串。&lt;s&gt;和&lt;e&gt;是一个数字。
</li>
<li>返回:返回字符串&lt;text&gt;中从&lt;s&gt;到&lt;e&gt;的单词字串。如果&lt;s&gt;比&lt;text&gt;中的单词数要大，那么返回空字符串。如果&lt;e&gt;大于&lt;text&gt;的单词数，那么返回从&lt;s&gt;开始，到&lt;text&gt;结束的单词串。
</li>
<li>示例: 
  <code>$(wordlist 2, 3, foo bar baz)</code> 返回值是“bar baz”。    
</li>
</ul>


</div>

</div>

<div id="outline-container-8-2-10" class="outline-4">
<h4 id="sec-8-2-10"><span class="section-number-4">8.2.10</span> words</h4>
<div class="outline-text-4" id="text-8-2-10">




<pre class="src src-makefile">$(words &lt;text&gt;)
</pre>

<ul>
<li>名称:单词个数统计函数——words。
</li>
<li>功能:统计&lt;text&gt;中字符串中的单词个数。
</li>
<li>返回:返回&lt;text&gt;中的单词数。
</li>
<li>示例: <code>$(words, foo bar baz)</code> 返回值是“3”。
</li>
<li>备注:如果我们要取&lt;text&gt;中最后的一个单词，我们可以这样: <code>$(word $(words &lt;text&gt;),&lt;text&gt;)</code> 。
</li>
</ul>


</div>

</div>

<div id="outline-container-8-2-11" class="outline-4">
<h4 id="sec-8-2-11"><span class="section-number-4">8.2.11</span> firstword</h4>
<div class="outline-text-4" id="text-8-2-11">




<pre class="src src-makefile">$(firstword &lt;text&gt;)
</pre>

<ul>
<li>名称:首单词函数——firstword。
</li>
<li>功能:取字符串&lt;text&gt;中的第一个单词。
</li>
<li>返回:返回字符串&lt;text&gt;的第一个单词。
</li>
<li>示例:$(firstword foo bar)返回值是“foo”。
</li>
<li>备注:这个函数可以用 word 函数来实现:$(word 1,&lt;text&gt;)。
</li>
</ul>


</div>

</div>

<div id="outline-container-8-2-12" class="outline-4">
<h4 id="sec-8-2-12"><span class="section-number-4">8.2.12</span> 字符串函数实例</h4>
<div class="outline-text-4" id="text-8-2-12">


<p>
以上，是所有的字符串操作函数，如果搭配混合使用，可以完成比较复杂的功能。
</p>
<p>
这里，举一个现实中应用的例子。我们知道，make 使用“VPATH”变量来指定“依赖文件”的搜索路径。于是，我们可以利用这个搜索路径来指定编译器对头文件的搜索路径参数 CFLAGS ，如:
</p>



<pre class="src src-makefile">override <span style="color: #ffd700; font-style: italic;">CFLAGS</span> += $(<span style="color: #ffd700; font-style: italic;">patsubst</span> %,-I%,$(<span style="color: #ffd700; font-style: italic;">subst</span> :, ,$(<span style="color: #ffd700; font-style: italic;">VPATH</span>)))
</pre>


<p>
如果我们的“$(VPATH)”值是“src:../headers”，那么 <code>$(patsubst %,-I%,$(subst :, ,$(VPATH)))</code> 将返回 <code>-Isrc -I../headers</code> ，这正是 cc 或 gcc 搜索头文件路径的参数。
</p>
</div>
</div>

</div>

<div id="outline-container-8-3" class="outline-3">
<h3 id="sec-8-3"><span class="section-number-3">8.3</span> 文件名操作函数</h3>
<div class="outline-text-3" id="text-8-3">


<p>
    下面我们要介绍的函数主要是处理文件名的。每个函数的参数字符串都会被当做一个或是一系列的文件名来对待。
</p>

</div>

<div id="outline-container-8-3-1" class="outline-4">
<h4 id="sec-8-3-1"><span class="section-number-4">8.3.1</span> dir</h4>
<div class="outline-text-4" id="text-8-3-1">




<pre class="src src-makefile">$(dir &lt;names...&gt;)
</pre>

<ul>
<li>名称:取目录函数——dir。
</li>
<li>功能:从文件名序列&lt;names&gt;中取出目录部分。目录部分是指最后一个反斜杠(“/”)之前的部分。如果没有反斜杠，那么返回“./”。
</li>
<li>返回:返回文件名序列&lt;names&gt;的目录部分。
</li>
<li>示例: <code>$(dir src/foo.c hacks)</code> 返回值是“src/ ./”。    
</li>
</ul>


</div>

</div>

<div id="outline-container-8-3-2" class="outline-4">
<h4 id="sec-8-3-2"><span class="section-number-4">8.3.2</span> notdir</h4>
<div class="outline-text-4" id="text-8-3-2">




<pre class="src src-makefile">$(notdir &lt;names...&gt;)
</pre>

<ul>
<li>名称:取文件名函数——notdir。
</li>
<li>功能:从文件名序列&lt;names&gt;中取出非目录部分。非目录部分是指最后一个反斜杠(“ /”)之后的部分。
</li>
<li>返回:返回文件名序列&lt;names&gt;的非目录部分。
</li>
<li>示例: <code>$(notdir src/foo.c hacks)</code> 返回值是“foo.c hacks”。    
</li>
</ul>


</div>

</div>

<div id="outline-container-8-3-3" class="outline-4">
<h4 id="sec-8-3-3"><span class="section-number-4">8.3.3</span> suffix</h4>
<div class="outline-text-4" id="text-8-3-3">




<pre class="src src-makefile">$(suffix &lt;names...&gt;)
</pre>

<ul>
<li>名称:取后缀函数——suffix。
</li>
<li>功能:从文件名序列&lt;names&gt;中取出各个文件名的后缀。
</li>
<li>返回:返回文件名序列&lt;names&gt;的后缀序列，如果文件没有后缀，则返回空字串。
</li>
<li>示例: <code>$(suffix src/foo.c src-1.0/bar.c hacks)</code> 返回值是“.c .c”。    
</li>
</ul>


</div>

</div>

<div id="outline-container-8-3-4" class="outline-4">
<h4 id="sec-8-3-4"><span class="section-number-4">8.3.4</span> basename</h4>
<div class="outline-text-4" id="text-8-3-4">




<pre class="src src-makefile">$(basename &lt;names...&gt;)
</pre>

<ul>
<li>名称:取前缀函数——basename。
</li>
<li>功能:从文件名序列&lt;names&gt;中取出各个文件名的前缀部分。
</li>
<li>返回:返回文件名序列&lt;names&gt;的前缀序列，如果文件没有前缀，则返回空字串。
</li>
<li>示例: <code>$(basename src/foo.c src-1.0/bar.c hacks)</code> 返回值是“src/foo src-1.0/bar hacks”。    
</li>
</ul>


</div>

</div>

<div id="outline-container-8-3-5" class="outline-4">
<h4 id="sec-8-3-5"><span class="section-number-4">8.3.5</span> addsuffix</h4>
<div class="outline-text-4" id="text-8-3-5">




<pre class="src src-makefile">$(addsuffix &lt;suffix&gt;,&lt;names...&gt;)
</pre>

<ul>
<li>名称:加后缀函数——addsuffix。
</li>
<li>功能:把后缀&lt;suffix&gt;加到&lt;names&gt;中的每个单词后面。
</li>
<li>返回:返回加过后缀的文件名序列。
</li>
<li>示例: <code>$(addsuffix .c,foo bar)</code> 返回值是“foo.c bar.c”。
</li>
</ul>


</div>

</div>

<div id="outline-container-8-3-6" class="outline-4">
<h4 id="sec-8-3-6"><span class="section-number-4">8.3.6</span> addprefix</h4>
<div class="outline-text-4" id="text-8-3-6">




<pre class="src src-makefile">$(addprefix &lt;prefix&gt;,&lt;names...&gt;)
</pre>

<ul>
<li>名称:加前缀函数——addprefix。
</li>
<li>功能:把前缀&lt;prefix&gt;加到&lt;names&gt;中的每个单词后面。
</li>
<li>返回:返回加过前缀的文件名序列。
</li>
<li>示例: <code>$(addprefix src/,foo bar)</code> 返回值是“src/foo src/bar”。    
</li>
</ul>


</div>

</div>

<div id="outline-container-8-3-7" class="outline-4">
<h4 id="sec-8-3-7"><span class="section-number-4">8.3.7</span> join</h4>
<div class="outline-text-4" id="text-8-3-7">




<pre class="src src-makefile">$(join &lt;list1&gt;,&lt;list2&gt;)
</pre>

<ul>
<li>名称:连接函数——join。
</li>
<li>功能:把&lt;list2&gt;中的单词对应地加到&lt;list1&gt;的单词后面。如果&lt;list1&gt;的单词个数要比&lt;list2&gt;的多，那么，&lt;list1&gt;中的多出来的单词将保持原样。如果&lt;list2&gt;的单词个数要比&lt;list1&gt;多，那么，&lt;list2&gt;多出来的单词将被复制到&lt;list2&gt;中。
</li>
<li>返回:返回连接过后的字符串。
</li>
<li>示例: <code>$(join aaa bbb , 111 222 333)</code> 返回值是“aaa111 bbb222 333”。
</li>
</ul>


</div>
</div>

</div>

<div id="outline-container-8-4" class="outline-3">
<h3 id="sec-8-4"><span class="section-number-3">8.4</span> foreach函数</h3>
<div class="outline-text-3" id="text-8-4">

<p>   foreach 函数和别的函数非常的不一样。因为这个函数是用来做循环用的，Makefile中的 foreach 函数几乎是仿照于 Unix 标准 Shell(/bin/sh)中的 for 语句，或是 C-Shell (/bin/csh)中的 foreach 语句而构建的。它的语法是:
</p>



<pre class="src src-makefile">$(foreach &lt;var&gt;,&lt;list&gt;,&lt;text&gt;)
</pre>


<p>
    这个函数的意思是，把参数&lt;list&gt;中的单词逐一取出放到参数&lt;var&gt;所指定的变量中，然后再执行&lt;text&gt;所包含的表达式。每一次&lt;text&gt;会返回一个字符串，循环过程中，&lt;text&gt;的所返回的每个字符串会以空格分隔，最后当整个循环结束时，&lt;text&gt;所返回的每个字符串所组成的整个字符串(以空格分隔)将会是 foreach 函数的返回值。
</p>
<p>    
    所以，&lt;var&gt;最好是一个变量名，&lt;list&gt;可以是一个表达式，而&lt;text&gt;中一般会使用&lt;var&gt;这个参数来依次枚举&lt;list&gt;中的单词。举个例子:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">names</span> := a b c d
<span style="color: #ffd700; font-style: italic;">files</span> := $(<span style="color: #ffd700; font-style: italic;">foreach</span> n,$(<span style="color: #ffd700; font-style: italic;">names</span>),$(<span style="color: #ffd700; font-style: italic;">n</span>).o)
</pre>


<p>
    上面的例子中，$(name)中的单词会被挨个取出，并存到变量“n”中，“$(n).o”每次根据“$(n)”计算出一个值，这些值以空格分隔，最后作为 foreach 函数的返回，所以，$(files)的值是“a.o b.o c.o d.o”。
</p>
<p>
    注意，foreach 中的&lt;var&gt;参数是一个临时的局部变量，foreach 函数执行完后，参数&lt;var&gt;的变量将不在作用，其作用域只在 foreach 函数当中。
</p>
</div>

</div>

<div id="outline-container-8-5" class="outline-3">
<h3 id="sec-8-5"><span class="section-number-3">8.5</span> if函数</h3>
<div class="outline-text-3" id="text-8-5">

<p>   if 函数很像 GNU 的 make 所支持的条件语句——<a href="#ifeq">ifeq</a>，if 函数的语法是:
</p>



<pre class="src src-makefile">$(if &lt;condition&gt;,&lt;then-part&gt;)
</pre>


<p>
   或是：
</p>



<pre class="src src-makefile">$(if &lt;condition&gt;,&lt;then-part&gt;,&lt;else-part&gt;)
</pre>


<p>
   可见，if 函数可以包含“else”部分，或是不含。即 if 函数的参数可以是两个，也可以是三个。&lt;condition&gt;参数是 if 的表达式，如果其返回的为非空字符串，那么这个表达式就相当于返回真，于是，&lt;then-part&gt;会被计算，否则&lt;else-part&gt;会被计算。
</p>
<p>
   而 if 函数的返回值是，如果&lt;condition&gt;为真(非空字符串)，那个&lt;then-part&gt;会是整个函数的返回值，如果&lt;condition&gt;为假(空字符串)，那么&lt;else-part&gt;会是整个函数的返回值，此时如果&lt;else-part&gt;没有被定义，那么，整个函数返回空字串。
</p>
<p>
   所以，&lt;then-part&gt;和&lt;else-part&gt;只会有一个被计算。
</p>
</div>

</div>

<div id="outline-container-8-6" class="outline-3">
<h3 id="sec-8-6"><span class="section-number-3">8.6</span> call函数</h3>
<div class="outline-text-3" id="text-8-6">

<p>   call 函数是唯一一个可以用来 <b>创建新的参数化的函数</b> 。你可以写一个非常复杂的表达式，这个表达式中，你可以定义许多参数，然后你可以用 call 函数来向这个表达式传递参数。其语法是:
</p>



<pre class="src src-makefile">$(call &lt;expression&gt;,&lt;parm1&gt;,&lt;parm2&gt;,&lt;parm3&gt;...)
</pre>


<p>
   当 make 执行这个函数时，&lt;expression&gt;参数中的变量，如$(1)，$(2)，$(3)等，会被参数&lt;parm1&gt;，&lt;parm2&gt;，&lt;parm3&gt;依次取代。而&lt;expression&gt;的返回值就是 call 函数的返回值。例如:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">reverse</span> = $(<span style="color: #ffd700; font-style: italic;">1</span>) $(<span style="color: #ffd700; font-style: italic;">2</span>)
<span style="color: #ffd700; font-style: italic;">foo</span> = $(<span style="color: #ffd700; font-style: italic;">call</span> reverse,a,b)
</pre>


<p>
那么，foo 的值就是“a b”。当然，参数的次序是可以自定义的，不一定是顺序的，如:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">reverse</span> = $(<span style="color: #ffd700; font-style: italic;">2</span>) $(<span style="color: #ffd700; font-style: italic;">1</span>)
<span style="color: #ffd700; font-style: italic;">foo</span> = $(<span style="color: #ffd700; font-style: italic;">call</span> reverse,a,b)
</pre>


<p>
此时的 foo 的值就是“b a”。
</p>
</div>

</div>

<div id="outline-container-8-7" class="outline-3">
<h3 id="sec-8-7"><span class="section-number-3">8.7</span> origin 函数</h3>
<div class="outline-text-3" id="text-8-7">

<p>   origin 函数不像其它的函数，他并不操作变量的值，他只是告诉你你的这个变量是哪里来的。
</p>
<p>
   其语法是:
</p>



<pre class="src src-makefile">$(origin &lt;variable&gt;)
</pre>


<p>
   注意，&lt;variable&gt;是变量的名字，不应该是引用。所以你最好不要在&lt;variable&gt;中使用“$”字符。Origin 函数会以其返回值来告诉你这个变量的“出生情况”，下面，是 origin函数的返回值:
</p>
<ul>
<li>"undefined"：如果&lt;variable&gt;从来没有定义过，origin 函数返回这个值“undefined”。
</li>
<li>"default": 如果&lt;variable&gt;是一个默认的定义，比如“CC”这个变量，这种变量我们将在后面讲述。
</li>
<li>"environment" 如果&lt;variable&gt;是一个环境变量，并且当 Makefile 被执行时，“-e”参数没有被打开。
</li>
<li>"file" 如果&lt;variable&gt;这个变量被定义在 Makefile 中。
</li>
<li>"command line" 如果&lt;variable&gt;这个变量是被命令行定义的。
</li>
<li>"override" 如果&lt;variable&gt;是被 override 指示符重新定义的。
</li>
<li>"automatic" 如果&lt;variable&gt;是一个命令运行中的自动化变量。关于自动化变量将在后面讲述。

<p>  
  这些信息对于我们编写 Makefile 是非常有用的，例如，假设我们有一个 Makefile 其包了一个定义文件 Make.def，在 Make.def 中定义了一个变量“bletch”，而我们的环境中也有一个环境变量“bletch”，此时，我们想判断一下，如果变量来源于环境，那么我们就把之重定义了，如果来源于 Make.def 或是命令行等非环境的，那么我们就不重新定义它。于是，在我们的 Makefile 中，BEGIN:
</p></li>
</ul>


<p>  
ifdef bletch
        ifeq "$(origin bletch)" "environment"
        bletch = barf, gag, etc.
        endif
endif
</p>
<p>
   当然，你也许会说，使用 override 关键字不就可以重新定义环境中的变量了吗?为什么需要使用这样的步骤?是的，我们用 override 是可以达到这样的效果，可是 override 过于粗暴，它同时会把从命令行定义的变量也覆盖了，而我们只想重新定义环境传来的，而不想重新定义命令行传来的。
</p>
</div>

</div>

<div id="outline-container-8-8" class="outline-3">
<h3 id="sec-8-8"><span class="section-number-3">8.8</span> shell函数</h3>
<div class="outline-text-3" id="text-8-8">

<p>   shell 函数也不像其它的函数。顾名思义，它的参数应该就是操作系统 Shell 的命令。它和反引号 <code>`</code> 是相同的功能。这就是说， <b>shell 函数把执行操作系统命令后的输出作为函数返回</b> 。于是，我们可以用操作系统命令以及字符串处理命令 awk，sed 等等命令来生成一个变量，如:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">contents</span> := $(<span style="color: #ffd700; font-style: italic;">shell</span> cat foo)
<span style="color: #ffd700; font-style: italic;">files</span> := $(<span style="color: #ffd700; font-style: italic;">shell</span> echo *.c)
</pre>


<p>
   注意，这个函数会新生成一个 Shell 程序来执行命令，所以你要注意其运行性能，如果你的Makefile 中有一些比较复杂的规则，并大量使用了这个函数，那么对于你的系统性能是有害的。特别是 Makefile 的隐晦的规则可能会让你的 shell 函数执行的次数比你想像的多得多。
</p>
</div>

</div>

<div id="outline-container-8-9" class="outline-3">
<h3 id="sec-8-9"><span class="section-number-3">8.9</span> 控制make的函数</h3>
<div class="outline-text-3" id="text-8-9">


<p>
   make 提供了一些函数来控制 make 的运行。通常，你需要检测一些运行 Makefile 时的运行时信息，并且根据这些信息来决定，你是让 make 继续执行，还是停止。
</p>

</div>

<div id="outline-container-8-9-1" class="outline-4">
<h4 id="sec-8-9-1"><span class="section-number-4">8.9.1</span> error</h4>
<div class="outline-text-4" id="text-8-9-1">




<pre class="src src-makefile">$(error &lt;text ...&gt;)
</pre>


<p>
    产生一个致命的错误，&lt;text &hellip;&gt;是错误信息。注意，error 函数不会在一被使用就会产生错误信息，所以如果你把其定义在某个变量中，并在后续的脚本中使用这个变量，那么也是可以的。例如:
</p>
<p>
示例一:
</p>



<pre class="src src-makefile">ifdef ERROR_001
$(<span style="color: #ffd700; font-style: italic;">error</span> error is $(<span style="color: #ffd700; font-style: italic;">ERROR_001</span>))
endif
</pre>


<p>
示例二:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">ERR</span> = $(<span style="color: #ffd700; font-style: italic;">error</span> found an error!)
<span style="color: #ffd700; font-weight: bold;">.PHONY</span>: err
<span style="color: #ffd700; font-weight: bold;">err</span>: ; $(<span style="color: #ffd700; font-style: italic;">ERR</span>)
</pre>


<p>
示例一会在变量 ERROR<sub>001</sub> 定义了后执行时产生 error 调用，而示例二则在目标 err 被执行时才发生 error 调用。
</p>
</div>

</div>

<div id="outline-container-8-9-2" class="outline-4">
<h4 id="sec-8-9-2"><span class="section-number-4">8.9.2</span> warning</h4>
<div class="outline-text-4" id="text-8-9-2">




<pre class="src src-makefile">$(warning &lt;text ...&gt;)
</pre>


<p>
    这个函数很像 error 函数，只是它并不会让 make 退出，只是输出一段警告信息，而 make 继续执行。
</p>
</div>
</div>
</div>

</div>

<div id="outline-container-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> make 的运行</h2>
<div class="outline-text-2" id="text-9">


<p>
  一般来说，最简单的就是直接在命令行下输入 make 命令，make 命令会找当前目录的makefile 来执行，一切都是自动的。但也有时你也许只想让 make 重编译某些文件，而不是整个工程，而又有的时候你有几套编译规则，你想在不同的时候使用不同的编译规则，等等。
</p>
<p>
  本章节就是讲述如何使用 make 命令的。
</p>

</div>

<div id="outline-container-9-1" class="outline-3">
<h3 id="sec-9-1"><span class="section-number-3">9.1</span> make 的退出码</h3>
<div class="outline-text-3" id="text-9-1">


<p>
   make  命令执行后有三个退出码:
</p>
<ul>
<li>0 - 表示成功执行。
</li>
<li>1 - 如果 make 运行时出现任何错误，其返回 1。
</li>
<li>2 - 如果你使用了 make 的“-q”选项，并且 make 使得一些目标不需要更新，那么返回 2。

<p>     
     Make 的相关参数我们会在后续章节中讲述。
</p></li>
</ul>


</div>

</div>

<div id="outline-container-9-2" class="outline-3">
<h3 id="sec-9-2"><span class="section-number-3">9.2</span> 指定 makefile</h3>
<div class="outline-text-3" id="text-9-2">


<p>
   前面我们说过，GNU make 找寻默认的 Makefile 的规则是在当前目录下依次找三个文件——“GNUmakefile”、“makefile”和“Makefile”。其按顺序找这三个文件，一旦找到，就开始读取这个文件并执行。
</p>
<p>
   当前，我们也可以给 make 命令指定一个特殊名字的 Makefile。要达到这个功能，我们要使用 make 的“-f”或是“&ndash;file”参数(“&ndash;makefile”参数也行)。例如，我们有个makefile 的名字是“hchen.mk”，那么，我们可以这样来让 make 来执行这个文件:
</p>



<pre class="src src-makefile">make -f hchen.mk
</pre>


<p>
   如果在 make 的命令行中，你不只一次地使用了“-f”参数，那么，所有指定的 makefile将会被连在一起传递给 make 执行。
</p>
</div>

</div>

<div id="outline-container-9-3" class="outline-3">
<h3 id="sec-9-3"><span class="section-number-3">9.3</span> 指定目标</h3>
<div class="outline-text-3" id="text-9-3">


<p>
   一般来说，make 的最终目标是 makefile 中的第一个目标，而其它目标一般是由这个目标连带出来的。这是 make 的默认行为。当然，一般来说，你的 makefile 中的第一个目标是由许多个目标组成，你可以指示 make，让其完成你所指定的目标。要达到这一目的很简单，需在 make 命令后直接跟目标的名字就可以完成(如前面提到的“make clean”形式)
</p>
<p>
   任何在 makefile 中的目标都可以被指定成终极目标，但是除了以“-”打头，或是包含了“=”的目标，因为有这些字符的目标，会被解析成命令行参数或是变量。甚至没有被我们明确写出来的目标也可以成为 make 的终极目标，也就是说，只要 make 可以找到其 <a href="#sec-10">隐含规则</a> 推导规则，那么这个隐含目标同样可以被指定成终极目标。
</p>
<p>
   有一个 make 的环境变量叫“MAKECMDGOALS”，这个变量中会 <b>存放你所指定的终极目标的列表</b> ，如果在命令行上，你没有指定目标，那么，这个变量是空值。这个变量可以让你使用在一些比较特殊的情形下。比如下面的例子:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-style: italic;">sources</span> = foo.c bar.c
ifneq ( $(<span style="color: #ffd700; font-style: italic;">MAKECMDGOALS</span>),clean)
<span style="color: #00ffff; font-weight: bold;">include</span> $(<span style="color: #ffd700; font-style: italic;">sources</span>:<span style="color: #ffd700; font-style: italic;">.c</span>=.d)
endif
</pre>


<p>
   基于上面的这个例子，只要我们输入的命令不是“make clean”，那么 makefile 会自动包含“foo.d”和“bar.d”这两个 makefile。
</p>
<p>
   使用指定终极目标的方法可以很方便地让我们编译我们的程序，例如下面这个例子:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">.PHONY</span>: all
<span style="color: #ffd700; font-weight: bold;">all</span>: prog1 prog2 prog3 prog4
</pre>


<p>
   从这个例子中，我们可以看到，这个 makefile 中有四个需要编译的程序——“prog1”，“prog2”， “prog3”和 “prog4”，我们可以使用“make all”命令来编译所有的目标(如果把 all 置成第一个目标，那么只需执行“make”)，我们也可以使用“make prog2”来单独编译目标“prog2”。即然 make 可以指定所有 makefile 中的目标，那么也包括“伪目标”，于是我们可以根据这种性质来让我们的 makefile 根据指定的不同的目标来完成不同的事。在 Unix 世界中，软件发布时，特别是 GNU 这种开源软件的发布时，其 makefile 都包含了编译、安装、打包等功能。我们可以参照这种规则来书写我们的 makefile 中的目标。
</p>
<ul>
<li>“all”这个伪目标是所有目标的目标，其功能一般是编译所有的目标。
</li>
<li>“clean” 这个伪目标功能是删除所有被 make 创建的文件。
</li>
<li>“install”这个伪目标功能是安装已编译好的程序，其实就是把目标执行文件拷贝到指定的目标中去。
</li>
<li>“print”这个伪目标的功能是例出改变过的源文件。
</li>
<li>“tar”这个伪目标功能是把源程序打包备份。也就是一个 tar 文件。
</li>
<li>“dist”这个伪目标功能是创建一个压缩文件，一般是把 tar 文件压成 Z 文件。或是 gz 文件。
</li>
<li>“TAGS”这个伪目标功能是更新所有的目标，以备完整地重编译使用。
</li>
<li>“check”和“test”这两个伪目标一般用来测试 makefile 的流程。
</li>
</ul>


<p>
   当然一个项目的 makefile 中也不一定要书写这样的目标，这些东西都是 GNU 的东西，但是我想，GNU 搞出这些东西一定有其可取之处(等你的 UNIX 下的程序文件一多时你就会发现这些功能很有用了)，这里只不过是说明了，如果你要书写这种功能，最好使用这种名字命名你的目标，这样规范一些，规范的好处就是——不用解释，大家都明白。而且如果你的 makefile 中有这些功能，一是很实用，二是可以显得你的 makefile 很专业(不是那种初学者的作品)。
</p>
</div>

</div>

<div id="outline-container-9-4" class="outline-3">
<h3 id="sec-9-4"><span class="section-number-3">9.4</span> 检查规则</h3>
<div class="outline-text-3" id="text-9-4">


<p>
   有时候，我们不想让我们的 makefile 中的规则执行起来，我们只想检查一下我们的命令，或是执行的序列。于是我们可以使用 make 命令的下述参数:
</p>



<pre class="example">“-n”
“--just-print”
“--dry-run”
“--recon”
</pre>


<p>
   不执行参数，这些参数只是打印命令，不管目标是否更新，把规则和连带规则下的命令打印出来，但不执行，这些参数对于我们调试 makefile 很有用处。
</p>



<pre class="example">“-t”
“--touch”
</pre>


<p>
   这个参数的意思就是把目标文件的时间更新，但不更改目标文件。也就是说，make 假装编译目标，但不是真正的编译目标，只是把目标变成已编译过的状态。
</p>



<pre class="example">“-q”
“--question”
</pre>


<p>
   这个参数的行为是找目标的意思，也就是说，如果目标存在，那么其什么也不会输出，当然也不会执行编译，如果目标不存在，其会打印出一条出错信息。
</p>



<pre class="example">“-W &lt;file&gt;”
“--what-if=&lt;file&gt;”
“--assume-new=&lt;file&gt;”
“--new-file=&lt;file&gt;”
</pre>


<p>
   这个参数需要指定一个文件。一般是是源文件(或依赖文件)，Make 会根据规则推导来运行依赖于这个文件的命令，一般来说，可以和“-n”参数一同使用，来查看这个依赖文件所发生的规则命令。
</p>
<p>
   另外一个很有意思的用法是结合“-p”和“-v”来输出 makefile 被执行时的信息(这个将在后面讲述)。
</p>
</div>

</div>

<div id="outline-container-9-5" class="outline-3">
<h3 id="sec-9-5"><span class="section-number-3">9.5</span> make 的参数</h3>
<div class="outline-text-3" id="text-9-5">


<p>
   下面列举了所有 GNU make 3.80 版的参数定义。其它版本和产商的 make 大同小异，不过其它产商的 make 的具体参数还是请参考各自的产品文档。
</p>



<pre class="example">“-b”
“-m”
</pre>


<p>
   这两个参数的作用是忽略和其它版本 make 的兼容性。
</p>



<pre class="example">“-B”
“--always-make”
</pre>


<p>
   认为所有的目标都需要更新(重编译)。
</p>



<pre class="example">“-C &lt;dir&gt;”
“--directory=&lt;dir&gt;”
</pre>


<p>
   指定读取 makefile 的目录。如果有多个“-C”参数，make 的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。
</p>
<p>   
如:
</p>



<pre class="example">“make -C ~hchen/test -C prog”
</pre>


<p>
等价于
</p>



<pre class="example">“make -C ~hchen/test/prog”
</pre>



<pre class="example">“--debug[=&lt;options&gt;]”
</pre>


<p>
输出 make 的调试信息。它有几种不同的级别可供选择，如果没有参数，那就是输出最简单的调试信息。下面是&lt;options&gt;的取值:
</p>
<ul>
<li>a —— 也就是 all，输出所有的调试信息。(会非常的多)
</li>
<li>b —— 也就是 basic，只输出简单的调试信息。即输出不需要重编译的目标。
</li>
<li>v —— 也就是 verbose，在 b 选项的级别之上。输出的信息包括哪个 makefile 被解析，不需要被重编译的依赖文件(或是依赖目标)等。
</li>
<li>i —— 也就是 implicit，输出所有的 <a href="#sec-10">隐含规则</a> 。
</li>
<li>j —— 也就是 jobs，输出执行规则中命令的详细信息，如命令的 PID、返回码等。
</li>
<li>m —— 也就是 makefile，输出 make 读取 makefile，更新 makefile，执行 makefile 的信息。
</li>
<li>“-d”相当于“&ndash;debug=a”。
</li>
<li>
</li>
</ul>





<pre class="example">“-e”
“--environment-overrides”
</pre>


<p>  
  指明环境变量的值覆盖 makefile 中定义的变量的值。
</p>
<ul>
<li>
</li>
</ul>





<pre class="example">“-f=&lt;file&gt;”
“--file=&lt;file&gt;”
“--makefile=&lt;file&gt;”
</pre>


<p>  
  指定需要执行的 makefile。
</p><ul>
<li>
</li>
</ul>





<pre class="example">“-h”
“--help”
</pre>


<p>  
  显示帮助信息。
</p>
<ul>
<li>
</li>
</ul>





<pre class="example">“-i”
“--ignore-errors”
</pre>


<p>  
  在执行时忽略所有的错误。
</p><ul>
<li>
</li>
</ul>





<pre class="example">“-I &lt;dir&gt;”
“--include-dir=&lt;dir&gt;”
</pre>


<p>  
  指定一个被包含 makefile 的搜索目标。可以使用多个“-I”参数来指定多个目录。
</p><ul>
<li>
</li>
</ul>





<pre class="example">“-j [&lt;jobsnum&gt;]”
“--jobs[=&lt;jobsnum&gt;]”
</pre>


<p>  
  指同时运行命令的个数。如果没有这个参数，make 运行命令时能运行多少就运行多少。如果有一个以上的“-j”参数，那么仅最后一个“-j”才是有效的。(注意这个参数在 MS-DOS中是无用的)
</p>
<ul>
<li>
</li>
</ul>





<pre class="example">“-k”
“--keep-going”
</pre>


<p>  
  出错也不停止运行。如果生成一个目标失败了，那么依赖于其上的目标就不会被执行了。
</p><ul>
<li>
</li>
</ul>





<pre class="example">“-l &lt;load&gt;”
“--load-average[=&lt;load]”
“—max-load[=&lt;load&gt;]”
</pre>


<p>  
  指定 make 运行命令的负载。
</p><ul>
<li>
</li>
</ul>





<pre class="example">“-n”
“--just-print”
“--dry-run”
“--recon”
</pre>


<p>  
  仅输出执行过程中的命令序列，但并不执行。
</p><ul>
<li>
</li>
</ul>





<pre class="example">“-o &lt;file&gt;”
“--old-file=&lt;file&gt;”
“--assume-old=&lt;file&gt;”
</pre>


<p>  
  不重新生成的指定的&lt;file&gt;，即使这个目标的依赖文件新于它。
</p><ul>
<li>
</li>
</ul>





<pre class="example">“-p”
“--print-data-base”
</pre>


<p>  
  输出 makefile 中的所有数据，包括所有的规则和变量。这个参数会让一个简单的 makefile都会输出一堆信息。如果你只是想输出信息而不想执行 makefile，你可以使用“make -qp”命令。如果你想查看执行 makefile 前的预设变量和规则，你可以使用“make -p -f /dev/null”。这个参数输出的信息会包含着你的 makefile 文件的文件名和行号，所以，用这个参数来调试你的 makefile 会是很有用的，特别是当你的环境变量很复杂的时候。
</p>
<ul>
<li>
</li>
</ul>





<pre class="example">“-q”
“--question”
</pre>


<p>  
  不运行命令，也不输出。仅仅是检查所指定的目标是否需要更新。如果是 0 则说明要更新，如果是 2 则说明有错误发生。
</p>
<ul>
<li>
</li>
</ul>





<pre class="example">“-r”
“--no-builtin-rules”
</pre>


<p> 
  禁止 make 使用任何<a href="#sec-10">隐含规则</a>。
</p>
<ul>
<li>
</li>
</ul>





<pre class="example">“-R”
“--no-builtin-variabes”
</pre>


<p>  
  禁止 make 使用任何作用于变量上的<a href="#sec-10">隐含规则</a>。
</p>
<ul>
<li>
</li>
</ul>





<pre class="example">“-s”
“--silent”
“--quiet”
</pre>


<p>
  在命令运行时不输出命令的输出。
</p>
<ul>
<li>
</li>
</ul>





<pre class="example">“-S”
“--no-keep-going”
“--stop”
</pre>


<p>
  取消“-k”选项的作用。因为有些时候，make 的选项是从环境变量“MAKEFLAGS”中继承下来的。所以你可以在命令行中使用这个参数来让环境变量中的“-k”选项失效。
</p>
<ul>
<li>
</li>
</ul>





<pre class="example">“-t”
“--touch”
</pre>


<p>
  相当于 UNIX 的 touch 命令，只是把目标的修改日期变成最新的，也就是阻止生成目标的命令运行。
</p>
<ul>
<li>
</li>
</ul>





<pre class="example">“-v”
“--version”
</pre>


<p>
  输出 make 程序的版本、版权等关于 make 的信息。
</p>
<ul>
<li>
</li>
</ul>





<pre class="example">“-w”
“--print-directory”
</pre>


<p>
  输出运行 makefile 之前和之后的信息。这个参数对于跟踪嵌套式调用 make 时很有用。
</p>
<ul>
<li>
</li>
</ul>





<pre class="example">“--no-print-directory”
</pre>


<p>
  禁止“-w”选项。
</p>
<ul>
<li>
</li>
</ul>





<pre class="example">“-W &lt;file&gt;”
“--what-if=&lt;file&gt;”
“--new-file=&lt;file&gt;”
“--assume-file=&lt;file&gt;”
</pre>


<p>
  假定目标&lt;file&gt;需要更新，如果和“-n”选项使用，那么这个参数会输出该目标更新时的运行动作。
</p>
<p>
  如果没有“-n”那么就像运行 UNIX 的“touch”命令一样，使得&lt;file&gt;的修改时间为当前时间。
</p>
<ul>
<li>
</li>
</ul>





<pre class="example">“--warn-undefined-variables”
</pre>


<p>
  只要 make 发现有未定义的变量，那么就输出警告信息。
</p>
</div>
</div>

</div>

<div id="outline-container-10" class="outline-2">
<h2 id="sec-10"><span class="section-number-2">10</span> 隐含规则</h2>
<div class="outline-text-2" id="text-10">


<p>
  在我们使用 Makefile 时，有一些我们会经常使用，而且使用频率非常高的东西，比如，我们编译 C/C++的源程序为中间目标文件(Unix 下是[.o]文件，Windows 下是[.obj]文件)。
</p>
<p>
  本章讲述的就是一些在 Makefile 中的“隐含的”，早先约定了的，不需要我们再写出来的规则。
</p>
<p>
  “隐含规则”也就是一种惯例，make 会按照这种“惯例”心照不喧地来运行，那怕我们的 Makefile 中没有书写这样的规则。例如，把[.c]文件编译成[.o]文件这一规则，你根本就不用写出来，make 会自动推导出这种规则，并生成我们需要的[.o]文件。
</p>
<p>
  “隐含规则”会使用一些我们系统变量，我们可以改变这些系统变量的值来定制隐含规则的运行时的参数。如系统变量“CFLAGS”可以控制编译时的编译器参数。
</p>
<p>
  我们还可以通过“模式规则”的方式写下自己的隐含规则。用“后缀规则”来定义隐含规则会有许多的限制。使用“模式规则”会更回得智能和清楚，但“后缀规则”可以用来保证我们 Makefile 的兼容性。
</p>
<p>
  我们了解了“隐含规则”，可以让其为我们更好的服务，也会让我们知道一些“约定俗成”了的东西，而不至于使得我们在运行 Makefile 时出现一些我们觉得莫名其妙的东西。
</p>
<p>
  当然，任何事物都是矛盾的，水能载舟，亦可覆舟，所以，有时候“隐含规则”也会给我们造成不小的麻烦。只有了解了它，我们才能更好地使用它。
</p>

</div>

<div id="outline-container-10-1" class="outline-3">
<h3 id="sec-10-1"><span class="section-number-3">10.1</span> 使用隐含规则</h3>
<div class="outline-text-3" id="text-10-1">


<p>
   如果要使用隐含规则生成你需要的目标，你所需要做的就是不要写出这个目标的规则。那么，make 会试图去自动推导产生这个目标的规则和命令，如果 make 可以自动推导生成这个目标的规则和命令，那么这个行为就是隐含规则的自动推导。当然，隐含规则是 make 事先约定好的一些东西。例如，我们有下面的一个 Makefile:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">foo</span> : foo.o bar.o
        cc -o foo foo.o bar.o $(<span style="color: #ffd700; font-style: italic;">CFLAGS</span>) $(<span style="color: #ffd700; font-style: italic;">LDFLAGS</span>)
</pre>


<p>
   我们可以注意到，这个 Makefile 中并没有写下如何生成 foo.o 和 bar.o 这两目标的规则和命令。因为 make 的“隐含规则”功能会自动为我们自动去推导这两个目标的依赖目标和生成命令。
</p>
<p>
   make 会在自己的“隐含规则”库中寻找可以用的规则，如果找到，那么就会使用。如果找不到，那么就会报错。在上面的那个例子中，make 调用的隐含规则是，把[.o]的目标的依赖文件置成[.c]，并使用 C 的编译命令“cc -c $(CFLAGS) [.c]”来生成[.o]的目标。
</p>
<p>
   也就是说，我们完全没有必要写下下面的两条规则:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">foo.o</span> : foo.c
cc -c foo.c $(<span style="color: #ffd700; font-style: italic;">CFLAGS</span>)
<span style="color: #ffd700; font-weight: bold;">bar.o</span> : bar.c
cc -c bar.c $(<span style="color: #ffd700; font-style: italic;">CFLAGS</span>)
</pre>


<p>
   因为，这已经是“约定”好了的事了，make 和我们约定好了用 C 编译器“cc”生成[.o]文件的规则，这就是隐含规则。
</p>
<p>
   当然，如果我们为[.o]文件书写了自己的规则，那么 make 就不会自动推导并调用隐含规则，它会按照我们写好的规则忠实地执行。
</p>
<p>
   还有，在 make 的“隐含规则库”中，每一条隐含规则都在库中有其顺序，越靠前的则是越被经常使用的，所以，这会导致我们有些时候即使我们显示地指定了目标依赖，make也不会管。如下面这条规则(没有命令):
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">foo.o</span> : foo.p
</pre>


<p>
   依赖文件“foo.p”(Pascal 程序的源文件)有可能变得没有意义。如果目录下存在了“foo.c”文件，那么我们的隐含规则一样会生效，并会通过“foo.c”调用 C 的编译器生成foo.o 文件。因为，在隐含规则中，Pascal 的规则出现在 C 的规则之后，所以，make 找到可以生成 foo.o 的 C 的规则就不再寻找下一条规则了。如果你确实不希望任何隐含规则推导，那么，你就不要只写出“依赖规则”，而不写命令。
</p>
</div>

</div>

<div id="outline-container-10-2" class="outline-3">
<h3 id="sec-10-2"><span class="section-number-3">10.2</span> 隐含规则一览</h3>
<div class="outline-text-3" id="text-10-2">


<p>
   这里我们将讲述所有预先设置(也就是 make 内建)的隐含规则，如果我们不明确地写下规则，那么，make 就会在这些规则中寻找所需要规则和命令。当然，我们也可以使用 make 的参数“-r”或“&ndash;no-builtin-rules”选项来取消所有的预设置的隐含规则。
</p>
<p>   
   当然，即使是我们指定了“-r”参数，某些隐含规则还是会生效，因为有许多的隐含规则都是使用了“后缀规则”来定义的，所以，只要隐含规则中有“后缀列表”(也就一系统定义在目标.SUFFIXES的依赖目标)，那么隐含规则就会生效。默认的后缀列表是:.out，.a， .ln， .o， .c， .cc， .C， .p， .f， .F， .r， .y， .l， .s， .S， .mod， .sym， .def， .h， .info， .dvi， .tex， .texinfo， .texi， .txinfo， .w， .ch .web， .sh， .elc， .el。具体的细节，我们会在后面讲述。
</p>
<p>
   还是先来看一看常用的隐含规则吧。
</p>

</div>

<div id="outline-container-10-2-1" class="outline-4">
<h4 id="sec-10-2-1"><span class="section-number-4">10.2.1</span> 编译 C 程序的隐含规则</h4>
<div class="outline-text-4" id="text-10-2-1">


<p>
   “&lt;n&gt;.o”的目标的依赖目标会自动推导为“&lt;n&gt;.c”，并且其生成命令是 <code>$(CC) -c $(CPPFLAGS) $(CFLAGS)</code>
</p>
</div>

</div>

<div id="outline-container-10-2-2" class="outline-4">
<h4 id="sec-10-2-2"><span class="section-number-4">10.2.2</span> 编译 C++程序的隐含规则</h4>
<div class="outline-text-4" id="text-10-2-2">


<p>
    “&lt;n&gt;.o”的目标的依赖目标会自动推导为“&lt;n&gt;.cc”或是“&lt;n&gt;.C”，并且其生成命令是 <code>$(CXX) -c $(CPPFLAGS) $(CFLAGS)</code> 。(建议使用“.cc”作为 C++源文件的后缀，而不是“.C”)
</p>
</div>

</div>

<div id="outline-container-10-2-3" class="outline-4">
<h4 id="sec-10-2-3"><span class="section-number-4">10.2.3</span> 编译 Pascal 程序的隐含规则</h4>
<div class="outline-text-4" id="text-10-2-3">


<p>
    “&lt;n&gt;.o”的目标的依赖目标会自动推导为“&lt;n&gt;.p”，并且其生成命令是 <code>$(PC) -c $(PFLAGS)</code> 。
</p></div>

</div>

<div id="outline-container-10-2-4" class="outline-4">
<h4 id="sec-10-2-4"><span class="section-number-4">10.2.4</span> 编译 Fortran/Ratfor 程序的隐含规则</h4>
<div class="outline-text-4" id="text-10-2-4">


<p>
    “&lt;n&gt;.o”的目标的依赖目标会自动推导为“&lt;n&gt;.r”或“&lt;n&gt;.F”或“&lt;n&gt;.f”，并且其生成命令是:
</p>



<pre class="example">“.f” “$(FC) -c $(FFLAGS)”
“.F” “$(FC) -c $(FFLAGS) $(CPPFLAGS)”
“.f” “$(FC) -c $(FFLAGS) $(RFLAGS)”
</pre>


</div>

</div>

<div id="outline-container-10-2-5" class="outline-4">
<h4 id="sec-10-2-5"><span class="section-number-4">10.2.5</span> 预处理 Fortran/Ratfor 程序的隐含规则</h4>
<div class="outline-text-4" id="text-10-2-5">


<p>
    “&lt;n&gt;.f”的目标的依赖目标会自动推导为“&lt;n&gt;.r”或“&lt;n&gt;.F”。这个规则只是转换 Ratfor 或有预处理的 Fortran 程序到一个标准的 Fortran 程序。其使用的命令是:
</p>



<pre class="example">“.F” “$(FC) -F $(CPPFLAGS) $(FFLAGS)”
“.r” “$(FC) -F $(FFLAGS) $(RFLAGS)”
</pre>


</div>

</div>

<div id="outline-container-10-2-6" class="outline-4">
<h4 id="sec-10-2-6"><span class="section-number-4">10.2.6</span> 编译 Modula-2 程序的隐含规则</h4>
<div class="outline-text-4" id="text-10-2-6">


<p>
    “&lt;n&gt;.sym”的目标的依赖目标会自动推导为“&lt;n&gt;.def”，并且其生成命令是:
</p>
<p>
    “$(M2C)$(M2FLAGS) $(DEFFLAGS)”。“&lt;n.o&gt;”的目标的依赖目标会自动推导为“&lt;n&gt;.mod”， 并且其生成命令是: <code>$(M2C) $(M2FLAGS) $(MODFLAGS)</code> 。
</p>
</div>

</div>

<div id="outline-container-10-2-7" class="outline-4">
<h4 id="sec-10-2-7"><span class="section-number-4">10.2.7</span> 汇编和汇编预处理的隐含规则</h4>
<div class="outline-text-4" id="text-10-2-7">


<p>
    “&lt;n&gt;.o” 的目标的依赖目标会自动推导为“&lt;n&gt;.s”，默认使用编译品“as”，并且其生成命令是: “$(AS) $(ASFLAGS)”。“&lt;n&gt;.s”的目标的依赖目标会自动推导为“&lt;n&gt;.S”，默认使用 C 预编译器“cpp”，并且其生成命令是: <code>$(AS) $(ASFLAGS)</code> 。
</p>
</div>

</div>

<div id="outline-container-10-2-8" class="outline-4">
<h4 id="sec-10-2-8"><span class="section-number-4">10.2.8</span> 链接 Object 文件的隐含规则</h4>
<div class="outline-text-4" id="text-10-2-8">


<p>
    “&lt;n&gt;”目标依赖于“&lt;n&gt;.o”，通过运行 C 的编译器来运行链接程序生成(一般是“ld”)，其生成命令是: <code>$(CC) $(LDFLAGS) &lt;n&gt;.o $(LOADLIBES) $(LDLIBS)</code> 。这个规则对于只有一个源文件的工程有效，同时也对多个 Object 文件(由不同的源文件生成)的也有效。例如如下规则:
</p>



<pre class="example">x : y.o z.o
</pre>


<p>
    并且“x.c”、“y.c”和“z.c”都存在时，隐含规则将执行如下命令:
</p>



<pre class="example">cc -c x.c -o x.o
cc -c y.c -o y.o
cc -c z.c -o z.o
cc x.o y.o z.o -o x
rm -f x.o
rm -f y.o
rm -f z.o
</pre>


<p>
    如果没有一个源文件(如上例中的 x.c)和你的目标名字(如上例中的 x)相关联，那么，你最好写出自己的生成规则，不然，隐含规则会报错的。
</p>
</div>

</div>

<div id="outline-container-10-2-9" class="outline-4">
<h4 id="sec-10-2-9"><span class="section-number-4">10.2.9</span> Yacc C 程序时的隐含规则</h4>
<div class="outline-text-4" id="text-10-2-9">


<p>
    “&lt;n&gt;.c”的依赖文件被自动推导为“n.y”(Yacc 生成的文件)，其生成命令是: <code>$(YACC) $(YFALGS)</code> 。(“Yacc”是一个语法分析器，关于其细节请查看相关资料)
</p>
</div>

</div>

<div id="outline-container-10-2-10" class="outline-4">
<h4 id="sec-10-2-10"><span class="section-number-4">10.2.10</span> Lex C 程序时的隐含规则</h4>
<div class="outline-text-4" id="text-10-2-10">


<p>
    “&lt;n&gt;.c”的依赖文件被自动推导为“n.l”(Lex 生成的文件)，其生成命令是: <code>$(LEX) $(LFALGS)</code> 。(关于“Lex”的细节请查看相关资料)
</p>
</div>

</div>

<div id="outline-container-10-2-11" class="outline-4">
<h4 id="sec-10-2-11"><span class="section-number-4">10.2.11</span> Lex Ratfor 程序时的隐含规则</h4>
<div class="outline-text-4" id="text-10-2-11">


<p>
    “&lt;n&gt;.r”的依赖文件被自动推导为“n.l”(Lex 生成的文件)，其生成命令是: <code>$(LEX) $(LFALGS)</code> 。
</p>
</div>

</div>

<div id="outline-container-10-2-12" class="outline-4">
<h4 id="sec-10-2-12"><span class="section-number-4">10.2.12</span> 从 C 程序、Yacc 文件或 Lex 文件创建 Lint 库的隐含规则</h4>
<div class="outline-text-4" id="text-10-2-12">


<p>
    “&lt;n&gt;.ln” (lint 生成的文件)的依赖文件被自动推导为“n.c”，其生成命令是: <code>$(LINT) $(LINTFALGS) $(CPPFLAGS) -i</code> 。对于“&lt;n&gt;.y”和“&lt;n&gt;.l”也是同样的规则。
</p>
</div>
</div>

</div>

<div id="outline-container-10-3" class="outline-3">
<h3 id="sec-10-3"><span class="section-number-3">10.3</span> 隐含规则使用的变量</h3>
<div class="outline-text-3" id="text-10-3">


<p>
   在隐含规则中的命令中，基本上都是使用了一些预先设置的变量。你可以在你的 makefile 中改变这些变量的值，或是在 make 的命令行中传入这些值，或是在你的环境变量中设置这些值，无论怎么样，只要设置了这些特定的变量，那么其就会对隐含规则起作用。
</p>
<p>
   当然，你也可以利用 make 的“-R”或“&ndash;no-builtin-variables”参数来取消你所定义的变量对隐含规则的作用。例如，第一条隐含规则——编译 C 程序的隐含规则的命令是 <code>$(CC) -c $(CFLAGS) $(CPPFLAGS)</code> 。Make 默认的编译命令是“cc”，如果你把变量“$(CC)”重定义成“gcc”，把变量“$(CFLAGS)”重定义成“-g”，那么，隐含规则中的命令全部会以 <code>gcc -c -g $(CPPFLAGS)</code> 的样子来执行了。
我们可以把隐含规则中使用的变量分成两种:一种是命令相关的，如“CC”;一种是参数相的关，如“CFLAGS”。下面是所有隐含规则中会用到的变量:
</p>

</div>

<div id="outline-container-10-3-1" class="outline-4">
<h4 id="sec-10-3-1"><span class="section-number-4">10.3.1</span> 关于命令的变量</h4>
<div class="outline-text-4" id="text-10-3-1">


<ul>
<li>AR: 函数库打包程序。默认命令是“ar”。
</li>
<li>AS: 汇编语言编译程序。默认命令是“as”。
</li>
<li>CC: C 语言编译程序。默认命令是“cc”。
</li>
<li>CXX: C++语言编译程序。默认命令是“g++”。
</li>
<li>CO: 从 RCS 文件中扩展文件程序。默认命令是“co”。
</li>
<li>CPP: C 程序的预处理器(输出是标准输出设备)。默认命令是“$(CC) -E”。
</li>
<li>FC: Fortran 和 Ratfor 的编译器和预处理程序。默认命令是“f77”。
</li>
<li>GET: 从 SCCS 文件中扩展文件的程序。默认命令是“get”。
</li>
<li>LEX: Lex 方法分析器程序(针对于 C 或 Ratfor)。默认命令是“lex”。
</li>
<li>PC: Pascal 语言编译程序。默认命令是“pc”。
</li>
<li>YACC: Yacc 文法分析器(针对于 C 程序)。默认命令是“yacc”。
</li>
<li>YACCR: Yacc 文法分析器(针对于 Ratfor 程序)。默认命令是“yacc -r”。
</li>
<li>MAKEINFO: 转换 Texinfo 源文件(.texi)到 Info 文件程序。默认命令是“makeinfo”。
</li>
<li>TEX: 从 TeX 源文件创建 TeX DVI 文件的程序。默认命令是“tex”。
</li>
<li>TEXI2DVI: 从 Texinfo 源文件创建军 TeX DVI 文件的程序。默认命令是“texi2dvi”。
</li>
<li>WEAVE: 转换 Web 到 TeX 的程序。默认命令是“weave”。
</li>
<li>CWEAVE: 转换 C Web 到 TeX 的程序。默认命令是“cweave”。
</li>
<li>TANGLE: 转换 Web 到 Pascal 语言的程序。默认命令是“tangle”。
</li>
<li>CTANGLE: 转换 C Web 到 C。默认命令是“ctangle”。
</li>
<li>RM: 删除文件命令。默认命令是“rm -f”。
</li>
</ul>


</div>

</div>

<div id="outline-container-10-3-2" class="outline-4">
<h4 id="sec-10-3-2"><span class="section-number-4">10.3.2</span> 关于命令参数的变量</h4>
<div class="outline-text-4" id="text-10-3-2">


<p>
    下面的这些变量都是相关上面的命令的参数。如果没有指明其默认值，那么其默认值都是空。
</p>
<ul>
<li>ARFLAGS: 函数库打包程序 AR 命令的参数。默认值是“rv”。
</li>
<li>ASFLAGS: 汇编语言编译器参数。(当明显地调用“.s”或“.S”文件时)。
</li>
<li>CFLAGS: C 语言编译器参数。
</li>
<li>CXXFLAGS: C++语言编译器参数。
</li>
<li>COFLAGS: RCS 命令参数。
</li>
<li>CPPFLAGS: C 预处理器参数。( C 和 Fortran 编译器也会用到)。
</li>
<li>FFLAGS: Fortran 语言编译器参数。
</li>
<li>GFLAGS: SCCS “get”程序参数。
</li>
<li>LDFLAGS: 链接器参数。(如:“ld”)
</li>
<li>LFLAGS: Lex 文法分析器参数。
</li>
<li>PFLAGS: Pascal 语言编译器参数。
</li>
<li>RFLAGS: Ratfor 程序的 Fortran 编译器参数。
</li>
<li>YFLAGS: Yacc 文法分析器参数。
</li>
</ul>


</div>
</div>

</div>

<div id="outline-container-10-4" class="outline-3">
<h3 id="sec-10-4"><span class="section-number-3">10.4</span> 隐含规则链</h3>
<div class="outline-text-3" id="text-10-4">


<p>
   有些时候，一个目标可能被一系列的隐含规则所作用。例如，一个[.o]的文件生成，可能会是先被 Yacc 的[.y]文件先成[.c]，然后再被 C 的编译器生成。我们把这一系列的隐含规则叫做“隐含规则链”。
</p>
<p>
   在上面的例子中，如果文件[.c]存在，那么就直接调用 C 的编译器的隐含规则，如果没有[.c]文件，但有一个[.y]文件，那么 Yacc 的隐含规则会被调用，生成[.c]文件，然后，再调用 C 编译的隐含规则最终由[.c]生成[.o]文件，达到目标。
</p>
<p>
   我们把这种[.c]的文件(或是目标)，叫做中间目标。不管怎么样，make 会努力自动推导生成目标的一切方法，不管中间目标有多少，其都会执着地把所有的隐含规则和你书写的规则全部合起来分析，努力达到目标，所以，有些时候，可能会让你觉得奇怪，怎么我的目标会这样生成?怎么我的 makefile 发疯了?
</p>
<p>
   在默认情况下，对于中间目标，它和一般的目标有两个地方所不同:第一个不同是除非中间的目标不存在，才会引发中间规则。第二个不同的是，只要目标成功产生，那么，产生最终目标过程中，所产生的中间目标文件会被以“rm -f”删除。通常，一个被 makefile 指定成目标或是依赖目标的文件不能被当作中介。然而，你可以明显地说明一个文件或是目标是中介目标，你可以使用伪目标“.INTERMEDIATE”来强制声明。(如:.INTERMEDIATE : mid)
</p>
<p>
   你也可以阻止make自动删除中间目标，要做到这一点，你可以使用伪目标“.SECONDARY”来强制声明(如:.SECONDARY : sec)。你还可以把你的目标，以模式的方式来指定(如:%.o)成伪目标“.PRECIOUS”的依赖目标，以保存被隐含规则所生成的中间文件。
</p>
<p>
   在“隐含规则链”中，禁止同一个目标出现两次或两次以上，这样一来，就可防止在make 自动推导时出现无限递归的情况。
</p>
<p>
   Make 会优化一些特殊的隐含规则，而不生成中间文件。如，从文件“foo.c”生成目标程序“foo”，按道理，make 会编译生成中间文件“foo.o”，然后链接成“foo”，但在实际情况下，这一动作可以被一条“cc”的命令完成(cc -o foo foo.c)，于是优化过的规则就不会生成中间文件。
</p>
</div>

</div>

<div id="outline-container-10-5" class="outline-3">
<h3 id="sec-10-5"><span class="section-number-3">10.5</span> 定义模式规则</h3>
<div class="outline-text-3" id="text-10-5">


<p>
   你可以使用模式规则来定义一个隐含规则。一个模式规则就好像一个一般的规则，只是在规则中，目标的定义需要有"%"字符。"%"的意思是表示一个或多个任意字符。在依赖目标中同样可以使用"%"，只是依赖目标中的"%"的取值，取决于其目标。
</p>
<p>
   有一点需要注意的是，"%"的展开发生在变量和函数的展开之后，变量和函数的展开发生在 make 载入 Makefile 时，而模式规则中的"%"则发生在运行时。
</p>

</div>

<div id="outline-container-10-5-1" class="outline-4">
<h4 id="sec-10-5-1"><span class="section-number-4">10.5.1</span> 模式规则介绍</h4>
<div class="outline-text-4" id="text-10-5-1">


<p>
    模式规则中，至少在规则的目标定义中要包含"%"，否则，就是一般的规则。目标中的"%"定义表示对文件名的匹配，"%"表示长度任意的非空字符串。例如:"%.c"表示以".c"结尾的文件名(文件名的长度至少为 3)，而"s.%.c"则表示以"s."开头，".c"结尾的文件名(文件名的长度至少为 5)。
</p>
<p>
    如果"%"定义在目标中，那么，目标中的"%"的值决定了依赖目标中的"%"的值，也就是说，目标中的模式的"%"决定了依赖目标中"%"的样子。例如有一个模式规则如下:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">%.o</span> : %.c ; &lt;command ......&gt;
</pre>


<p>
    其含义是，指出了怎么从所有的[.c]文件生成相应的[.o]文件的规则。如果要生成的目标是"a.o b.o"，那么"%c"就是"a.c b.c"。
</p>
<p>
    一旦依赖目标中的"%"模式被确定，那么，make 会被要求去匹配当前目录下所有的文件名，一旦找到，make 就会规则下的命令，所以，在模式规则中，目标可能会是多个的，如果有模式匹配出多个目标，make 就会产生所有的模式目标，此时，make 关心的是依赖的文件名和生成目标的命令这两件事。
</p>
</div>

</div>

<div id="outline-container-10-5-2" class="outline-4">
<h4 id="sec-10-5-2"><span class="section-number-4">10.5.2</span> 模式规则示例</h4>
<div class="outline-text-4" id="text-10-5-2">


<p>
    下面这个例子表示了，把所有的[.c]文件都编译成[.o]文件.
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">%.o</span> : %.c
        $(<span style="color: #ffd700; font-style: italic;">CC</span>) -c $(<span style="color: #ffd700; font-style: italic;">CFLAGS</span>) $(<span style="color: #ffd700; font-style: italic;">CPPFLAGS</span>) $<span style="color: #b0c4de; font-weight: bold;">&lt;</span> -o <span style="color: #ffd700; font-weight: bold;">$</span><span style="color: #ffd700; font-weight: bold;">@</span>
</pre>


<p>
    其中，"$@"表示所有的目标的挨个值，"$&lt;"表示了所有依赖目标的挨个值。这些奇怪的变量我们叫"自动化变量"，后面会详细讲述。
</p>
<p>
    下面的这个例子中有两个目标是模式的:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">%.tab.c %.tab.h</span>: %.y
bison -d $<span style="color: #b0c4de; font-weight: bold;">&lt;</span>
</pre>


<p>
    这条规则告诉make把所有的[.y]文件都以"bison -d &lt;n&gt;.y"执行，然后生成"&lt;n&gt;.tab.c"和"&lt;n&gt;.tab.h"文件。(其中，"&lt;n&gt;"表示一个任意字符串)。如果我们的执行程序 "foo"依赖于文件 "parse.tab.o" 和 "scan.o" ，并且文件 "scan.o" 依赖于文件"parse.tab.h"，如果"parse.y"文件被更新了，那么根据上述的规则，"bison -d parse.y" 就会被执行一次，于是，"parse.tab.o"和"scan.o"的依赖文件就齐了。(假设，"parse.tab.o"由"parse.tab.c"生成，和"scan.o"由"scan.c"生成，而"foo"由"parse.tab.o"和"scan.o"链接生成，而且 foo 和其[.o]文件的依赖关系也写好，那么，所有的目标都会得到满足)
</p>
</div>

</div>

<div id="outline-container-10-5-3" class="outline-4">
<h4 id="sec-10-5-3"><span class="section-number-4">10.5.3</span> <span class="target">自动化变量</span></h4>
<div class="outline-text-4" id="text-10-5-3">


<p>
    在上述的模式规则中，目标和依赖文件都是一系例的文件，那么我们如何书写一个命令来完成从不同的依赖文件生成相应的目标?因为在每一次的对模式规则的解析时，都会是不同的目标和依赖文件。
</p>
<p>
    自动化变量就是完成这个功能的。在前面，我们已经对自动化变量有所提涉，相信你看到这里已对它有一个感性认识了。所谓自动化变量，就是这种变量会把模式中所定义的一系列的文件自动地挨个取出，直至所有的符合模式的文件都取完了。这种自动化变量只应出现在规则的命令中。
</p>
<p>
    下面是所有的自动化变量及其说明:
</p>

<ul>
<li>$@: 表示规则中的目标文件集。在模式规则中，如果有多个目标，那么，"$@"就是匹配于目标中模式定义的集合。
</li>
<li>$%: 仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是"foo.a (bar.o)"，那么，"$%"就是"bar.o"，"$@"就是"foo.a"。如果目标不是函数库文件(Unix 下是[.a]，Windows 下是[.lib])，那么，其值为空。
</li>
<li>$&lt;: 依赖目标中的第一个目标名字。如果依赖目标是以模式(即"%")定义的，那么"$&lt;"将是符合模式的一系列的文件集。注意，其是一个一个取出来的。
</li>
<li>$?: 所有比目标新的依赖目标的集合。以空格分隔。
</li>
<li>$^: 所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量会去除重复的依赖目标，只保留一份。
</li>
<li>$+: 这个变量很像"$^"，也是所有依赖目标的集合。只是它不去除重复的依赖目标。
</li>
<li>$*: 这个变量表示目标模式中"%"及其之前的部分。如果目标是"dir/a.foo.b"，并且目标的模式是"a.%.b"，那么，"$*"的值就是"dir/a.foo"。这个变量对于构造有关联的文件名是比较有较。如果目标中没有模式的定义，那么"$*"也就不能被推导出，但是，如果目标文件的后缀是 make 所识别的，那么"$*"就是除了后缀的那一部分。例如:如果目标是"foo.c"，因为".c"是 make 所能识别的后缀名，所以，"$*"的值就是"foo"。这个特性是 GNU make 的，很有可能不兼容于其它版本的 make，所以，你应该尽量避免使用"$*"，除非是在隐含规则或是静态模式中。如果目标中的后缀是 make 所不能识别的，那么"$*"就是空值。当你希望只对更新过的依赖文件进行操作时，"$?"在显式规则中很有用，例如，假设有一个函数库文件叫"lib"，其由其它几个 object 文件更新。那么把 object 文件打包的比较有效率的 Makefile 规则是:
</li>
</ul>




<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">lib</span> : foo.o bar.o lose.o win.o
ar r lib $<span style="color: #b0c4de; font-weight: bold;">?</span>
</pre>


<p>
    在上述所列出来的自动量变量中。四个变量($@、$&lt;、$%、$*)在扩展时只会有一个文件，而另三个的值是一个文件列表。这七个自动化变量还可以取得文件的目录名或是在当前目录下的符合模式的文件名，只需要搭配上"D"或"F"字样。这是 GNU make 中老版本的特性，在新版本中，我们使用函数"dir"或"notdir"就可以做到了。"D"的含义就是 Directory，就是目录，"F"的含义就是 File，就是文件。
</p>
<p>
    下面是对于上面的七个变量分别加上"D"或是"F"的含义:
</p>
<ul>
<li>$(@D): 表示"$@"的目录部分(不以斜杠作为结尾)，如果"$@"值是"dir/foo.o"，那么"$(@D)"就是"dir"，而如果"$@"中没有包含斜杠的话，其值就是"."(当前目录)。
</li>
<li>$(@F): 表示"$@"的文件部分，如果"$@"值是"dir/foo.o"，那么"$(@F)"就是"foo.o"，"$(@F)"相当于函数"$(notdir $@)"。
</li>
<li>"$(*D)"和"$(*F)": 和上面所述的同理，也是取文件的目录部分和文件部分。对于上面的那个例子，"$(*D)"返回"dir"，而"$(*F)"返回"foo"
</li>
<li>"$(%D)"和"$(%F)": 分别表示了函数包文件成员的目录部分和文件部分。这对于形同"archive(member)"形式的目标中的"member"中包含了不同的目录很有用。
</li>
<li>"$(&lt;D)"和"$(&lt;F)": 分别表示依赖文件的目录部分和文件部分。
</li>
<li>"$(<sup>D</sup>)"和"$(<sup>F</sup>)": 分别表示所有依赖文件的目录部分和文件部分。(无相同的)
</li>
<li>"$(+D)"和"$(+F)": 分别表示所有依赖文件的目录部分和文件部分。(可以有相同的)
</li>
<li>"$(?D)"和"$(?F)": 分别表示被更新的依赖文件的目录部分和文件部分。

<p>  
  最后想提醒一下的是，对于"$&lt;"，为了避免产生不必要的麻烦，我们最好给$后面的那个特定字符都加上圆括号，比如，"$(&lt;)"就要比"$&lt;"要好一些。
</p>
<p>  
  还得要注意的是，这些变量只使用在规则的命令中，而且一般都是"<a href="#">显式规则</a>"和"<a href="#sec-4-7">静态模式规则</a>"(参见前面"书写规则"一章)。其在隐含规则中并没有意义。  
</p></li>
</ul>


</div>
</div>

</div>

<div id="outline-container-10-6" class="outline-3">
<h3 id="sec-10-6"><span class="section-number-3">10.6</span> 模式的匹配</h3>
<div class="outline-text-3" id="text-10-6">


<p>
   一般来说，一个目标的模式有一个有前缀或是后缀的"%"，或是没有前后缀，直接就是一个"%"。因为"%"代表一个或多个字符，所以在定义好了的模式中，我们把"%"所匹配的内容叫做"茎"，例如"%.c"所匹配的文件"test.c"中"test"就是"茎"。因为在目标和依赖目标中同时有"%"时，依赖目标的"茎"会传给目标，当做目标中的"茎"。
</p>
<p>
   当一个模式匹配包含有斜杠(实际也不经常包含)的文件时，那么在进行模式匹配时，目录部分会首先被移开，然后进行匹配，成功后，再把目录加回去。在进行"茎"的传递时，我们需要知道这个步骤。例如有一个模式"e%t"，文件"src/eat"匹配于该模式，于是"src/a"就是其"茎"，如果这个模式定义在依赖目标中，而被依赖于这个模式的目标中又有个模式"c%r"，那么，目标就是"src/car"。("茎"被传递)
</p>
</div>

</div>

<div id="outline-container-10-7" class="outline-3">
<h3 id="sec-10-7"><span class="section-number-3">10.7</span> 重载内建隐含规则</h3>
<div class="outline-text-3" id="text-10-7">


<p>
   你可以重载内建的隐含规则(或是定义一个全新的)，例如你可以重新构造和内建隐含规则不同的命令，如:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">%.o</span> : %.c
        $(<span style="color: #ffd700; font-style: italic;">CC</span>) -c $(<span style="color: #ffd700; font-style: italic;">CPPFLAGS</span>) $(<span style="color: #ffd700; font-style: italic;">CFLAGS</span>) -D$(<span style="color: #ffd700; font-style: italic;">date</span>)
</pre>


<p>
   你可以取消内建的隐含规则，只要不在后面写命令就行。如:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">%.o</span> : %.s
</pre>


</div>

</div>

<div id="outline-container-10-8" class="outline-3">
<h3 id="sec-10-8"><span class="section-number-3">10.8</span> 老式风格的"后缀规则"</h3>
<div class="outline-text-3" id="text-10-8">


<p>
   后缀规则是一个比较老式的定义隐含规则的方法。后缀规则会被模式规则逐步地取代。因为模式规则更强更清晰。为了和老版本的 Makefile 兼容，GNU make 同样兼容于这些东西。后缀规则有两种方式:"双后缀"和"单后缀"。
</p>
<p>
   双后缀规则定义了一对后缀:目标文件的后缀和依赖目标(源文件)的后缀。如".c.o"相当于"%o : %c"。单后缀规则只定义一个后缀，也就是源文件的后缀。如".c"相当于"% :%.c"。
</p>
<p>
   后缀规则中所定义的后缀应该是 make 所认识的，如果一个后缀是 make 所认识的，那么这个规则就是单后缀规则，而如果两个连在一起的后缀都被 make 所认识，那就是双后缀规则。例如:".c"和".o"都是 make 所知道。因而，如果你定义了一个规则是".c.o"那么其就是双后缀规则，意义就是".c"是源文件的后缀，".o"是目标文件的后缀。如下示例:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">.c.o</span>:
        $(<span style="color: #ffd700; font-style: italic;">CC</span>) -c $(<span style="color: #ffd700; font-style: italic;">CFLAGS</span>) $(<span style="color: #ffd700; font-style: italic;">CPPFLAGS</span>) -o <span style="color: #ffd700; font-weight: bold;">$</span><span style="color: #ffd700; font-weight: bold;">@</span> $<span style="color: #b0c4de; font-weight: bold;">&lt;</span>
</pre>


<p>
   后缀规则不允许任何的依赖文件，如果有依赖文件的话，那就不是后缀规则，那些后缀统统被认为是文件名，如:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">.c.o</span>: foo.h
        $(<span style="color: #ffd700; font-style: italic;">CC</span>) -c $(<span style="color: #ffd700; font-style: italic;">CFLAGS</span>) $(<span style="color: #ffd700; font-style: italic;">CPPFLAGS</span>) -o <span style="color: #ffd700; font-weight: bold;">$</span><span style="color: #ffd700; font-weight: bold;">@</span> $<span style="color: #b0c4de; font-weight: bold;">&lt;</span>
</pre>


<p>
   这个例子，就是说，文件".c.o"依赖于文件"foo.h"，而不是我们想要的这样:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">%.o</span>: %.c foo.h
        $(<span style="color: #ffd700; font-style: italic;">CC</span>) -c $(<span style="color: #ffd700; font-style: italic;">CFLAGS</span>) $(<span style="color: #ffd700; font-style: italic;">CPPFLAGS</span>) -o <span style="color: #ffd700; font-weight: bold;">$</span><span style="color: #ffd700; font-weight: bold;">@</span> $<span style="color: #b0c4de; font-weight: bold;">&lt;</span>
</pre>


<p>
   后缀规则中，如果没有命令，那是毫无意义的。因为他也不会移去内建的隐含规则。而要让 make 知道一些特定的后缀，我们可以使用伪目标".SUFFIXES"来定义或是删除，如:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">.SUFFIXES</span>: .hack .win
</pre>


<p>
   把后缀.hack 和.win 加入后缀列表中的末尾。
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">.SUFFIXES</span>: <span style="color: #ffd700;"># </span><span style="color: #ffd700;">&#21024;&#38500;&#40664;&#35748;&#30340;&#21518;&#32512;</span>
<span style="color: #ffd700; font-weight: bold;">.SUFFIXES</span>: .c .o .h <span style="color: #ffd700;"># </span><span style="color: #ffd700;">&#23450;&#20041;&#33258;&#24049;&#30340;&#21518;&#32512;</span>
</pre>


<p>
   先清楚默认后缀，后定义自己的后缀列表。
</p>
<p>
   make 的参数"-r"或"-no-builtin-rules"也会使用得默认的后缀列表为空。而变量"SUFFIXE"被用来定义默认的后缀列表，你可以用".SUFFIXES"来改变后缀列表，但请不要改变变量"SUFFIXE"的值。
</p>
</div>

</div>

<div id="outline-container-10-9" class="outline-3">
<h3 id="sec-10-9"><span class="section-number-3">10.9</span> 隐含规则搜索算法</h3>
<div class="outline-text-3" id="text-10-9">


<p>
   比如我们有一个目标叫 T。下面是搜索目标 T 的规则的算法。请注意，在下面，我们没有提到后缀规则，原因是，所有的后缀规则在 Makefile 被载入内存时，会被转换成模式规则。如果目标是"archive(member)"的函数库文件模式，那么这个算法会被运行两次，第一次是找目标 T，如果没有找到的话，那么进入第二次，第二次会把"member"当作 T 来搜索。
</p>
<ol>
<li>把 T 的目录部分分离出来。叫 D，而剩余部分叫 N。(如:如果 T 是"src/foo.o"，那么，D 就是"src/"，N 就是"foo.o")
</li>
<li>创建所有匹配于 T 或是 N 的模式规则列表。
</li>
<li>如果在模式规则列表中有匹配所有文件的模式，如"%"，那么从列表中移除其它的模式。
</li>
<li>移除列表中没有命令的规则。
</li>
<li>对于第一个在列表中的模式规则:
<ol>
<li>推导其"茎"S，S 应该是 T 或是 N 匹配于模式中"%"非空的部分。
</li>
<li>计算依赖文件。把依赖文件中的"%"都替换成"茎"S。如果目标模式中没有包含斜框字符，而把 D 加在第一个依赖文件的开头。
</li>
<li>测试是否所有的依赖文件都存在或是理当存在。(如果有一个文件被定义成另外一个规则的目标文件，或者是一个显式规则的依赖文件，那么这个文件就叫"理当存在")
</li>
<li>如果所有的依赖文件存在或是理当存在，或是就没有依赖文件。那么这条规则将被采用，退出该算法。
</li>
</ol>

</li>
<li>如果经过第 5 步，没有模式规则被找到，那么就做更进一步的搜索。对于存在于列表中的第一个模式规则:
<ol>
<li>如果规则是终止规则，那就忽略它，继续下一条模式规则。
</li>
<li>计算依赖文件。(同第 5 步)
</li>
<li>测试所有的依赖文件是否存在或是理当存在。
</li>
<li>对于不存在的依赖文件，递归调用这个算法查找他是否可以被隐含规则找到。
</li>
<li>如果所有的依赖文件存在或是理当存在，或是就根本没有依赖文件。那么这条规则被采用，退出该算法。
</li>
</ol>

</li>
<li>如果没有隐含规则可以使用，查看".DEFAULT"规则，如果有，采用，把".DEFAULT"的命令给 T 使用。
</li>
</ol>


<p>      
   一旦规则被找到，就会执行其相当的命令，而此时，我们的自动化变量的值才会生成。
</p>
</div>
</div>

</div>

<div id="outline-container-11" class="outline-2">
<h2 id="sec-11"><span class="section-number-2">11</span> 使用 make 更新函数库文件</h2>
<div class="outline-text-2" id="text-11">


<p>
  函数库文件也就是对 Object 文件(程序编译的中间文件)的打包文件。在 Unix 下，一般是由命令"ar"来完成打包工作。
</p>

</div>

<div id="outline-container-11-1" class="outline-3">
<h3 id="sec-11-1"><span class="section-number-3">11.1</span> 函数库文件的成员</h3>
<div class="outline-text-3" id="text-11-1">


<p>
   一个函数库文件由多个文件组成。你可以以如下格式指定函数库文件及其组成:
</p>



<pre class="example">archive(member)
</pre>


<p>
   这个不是一个命令，而一个目标和依赖的定义。一般来说，这种用法基本上就是为了"ar"命令来服务的。如:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">foolib(hack.o)</span> : hack.o
ar cr foolib hack.o
</pre>


<p>
   如果要指定多个 member，那就以空格分开，如:
</p>



<pre class="src src-makefile">foolib(hack.o kludge.o)
</pre>


<p>
   其等价于:
</p>



<pre class="src src-makefile">foolib(hack.o) foolib(kludge.o)
</pre>


<p>
   你还可以使用 Shell 的文件通配符来定义，如:
</p>



<pre class="src src-makefile">foolib(*.o)
</pre>


</div>

</div>

<div id="outline-container-11-2" class="outline-3">
<h3 id="sec-11-2"><span class="section-number-3">11.2</span> 函数库成员的隐含规则</h3>
<div class="outline-text-3" id="text-11-2">


<p>
   当 make 搜索一个目标的隐含规则时，一个特殊的特性是，如果这个目标是"a(m)"形式的，其会把目标变成"(m)"。于是，如果我们的成员是"%.o"的模式定义，并且如果我们使用 <code>make foo.a(bar.o)</code> 的形式调用 Makefile 时，隐含规则会去找"bar.o"的规则，如果没有定义 bar.o 的规则，那么内建隐含规则生效，make 会去找 bar.c 文件来生成 bar.o，如果找得到的话，make 执行的命令大致如下:
</p>



<pre class="src src-makefile">cc -c bar.c -o bar.o
ar r foo.a bar.o
rm -f bar.o
</pre>


<p>
   还有一个变量要注意的是"$%"，这是专属函数库文件的自动化变量，有关其说明请参见"<a href="#sec-10-5-3">自动化变量</a>"一节。
</p>
</div>

</div>

<div id="outline-container-11-3" class="outline-3">
<h3 id="sec-11-3"><span class="section-number-3">11.3</span> 函数库文件的后缀规则</h3>
<div class="outline-text-3" id="text-11-3">


<p>
   你可以使用"后缀规则"和"隐含规则"来生成函数库打包文件，如:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">.c.a</span>:
        $(<span style="color: #ffd700; font-style: italic;">CC</span>) $(<span style="color: #ffd700; font-style: italic;">CFLAGS</span>) $(<span style="color: #ffd700; font-style: italic;">CPPFLAGS</span>) -c $<span style="color: #b0c4de; font-weight: bold;">&lt;</span> -o <span style="color: #ffd700; font-weight: bold;">$</span><span style="color: #ffd700; font-weight: bold;">*</span>.o
        $(<span style="color: #ffd700; font-style: italic;">AR</span>) r <span style="color: #ffd700; font-weight: bold;">$</span><span style="color: #ffd700; font-weight: bold;">@</span> <span style="color: #ffd700; font-weight: bold;">$</span><span style="color: #ffd700; font-weight: bold;">*</span>.o
        $(<span style="color: #ffd700; font-style: italic;">RM</span>) <span style="color: #ffd700; font-weight: bold;">$</span><span style="color: #ffd700; font-weight: bold;">*</span>.o
</pre>


<p>
   其等效于:
</p>



<pre class="src src-makefile"><span style="color: #ffd700; font-weight: bold;">(%.o)</span> : %.c
        $(<span style="color: #ffd700; font-style: italic;">CC</span>) $(<span style="color: #ffd700; font-style: italic;">CFLAGS</span>) $(<span style="color: #ffd700; font-style: italic;">CPPFLAGS</span>) -c $<span style="color: #b0c4de; font-weight: bold;">&lt;</span> -o <span style="color: #ffd700; font-weight: bold;">$</span><span style="color: #ffd700; font-weight: bold;">*</span>.o
        $(<span style="color: #ffd700; font-style: italic;">AR</span>) r <span style="color: #ffd700; font-weight: bold;">$</span><span style="color: #ffd700; font-weight: bold;">@</span> <span style="color: #ffd700; font-weight: bold;">$</span><span style="color: #ffd700; font-weight: bold;">*</span>.o
        $(<span style="color: #ffd700; font-style: italic;">RM</span>) <span style="color: #ffd700; font-weight: bold;">$</span><span style="color: #ffd700; font-weight: bold;">*</span>.o      
</pre>


</div>

</div>

<div id="outline-container-11-4" class="outline-3">
<h3 id="sec-11-4"><span class="section-number-3">11.4</span> 注意事项</h3>
<div class="outline-text-3" id="text-11-4">


<p>
   在进行函数库打包文件生成时，请小心使用 make 的并行机制("-j"参数)。如果多个 ar 命令在同一时间运行在同一个函数库打包文件上，就很有可以损坏这个函数库文件。所以，在 make 未来的版本中，应该提供一种机制来避免并行操作发生在函数打包文件上。
</p>
<p>
   但就目前而言，你还是应该不要尽量不要使用"-j"参数。
</p>
</div>
</div>

</div>

<div id="outline-container-12" class="outline-2">
<h2 id="sec-12"><span class="section-number-2">12</span> 后序</h2>
<div class="outline-text-2" id="text-12">


<p>
  终于到写结束语的时候了，以上基本上就是 GNU make 的 Makefile 的所有细节了。其它的产商的 make 基本上也就是这样的，无论什么样的 make，都是以文件的依赖性为基础的，其基本是都是遵循一个标准的。这篇文档中 80%的技术细节都适用于任何的 make，我猜测"函数"那一章的内容可能不是其它 make 所支持的，而隐含规则方面，我想不同的 make 会有不同的实现，我没有精力来查看 GNU 的 make 和 VC 的 nmake、BCB 的 make，或是别的 UNIX下的 make 有些什么样的差别，一是时间精力不够，二是因为我基本上都是在 Unix 下使用make，以前在 SCO Unix 和 IBM 的 AIX，现在在 Linux、Solaris、HP-UX、AIX 和 Alpha 下使用，Linux 和 Solaris 下更多一点。不过，我可以肯定的是，在 Unix 下的 make，无论是哪种平台，几乎都使用了 Richard Stallman 开发的 make 和 cc/gcc 的编译器，而且，基本上都是 GNU 的 make(公司里所有的 UNIX 机器上都被装上了 GNU 的东西，所以，使用 GNU 的程序也就多了一些)。GNU 的东西还是很不错的，特别是使用得深了以后，越来越觉得 GNU 的软件的强大，也越来越觉得 GNU 的在操作系统中(主要是 Unix，甚至 Windows)"杀伤力"。
</p>
<p>
  对于上述所有的 make 的细节，我们不但可以利用 make 这个工具来编译我们的程序，还可以利用 make 来完成其它的工作，因为规则中的命令可以是任何 Shell 之下的命令，所以，在 Unix 下，你不一定只是使用程序语言的编译器，你还可以在 Makefile 中书写其它的命令，如:tar、awk、mail、sed、cvs、compress、ls、rm、yacc、rpm、ftp&hellip;&hellip;等等，等等，来完成诸如"程序打包"、"程序备份"、"制作程序安装包"、"提交代码"、"使用程序模板"、"合并文件"等等五花八门的功能，文件操作，文件管理，编程开发设计，或是其它一些异想天开的东西。比如，以前在书写银行交易程序时，由于银行的交易程序基本一样，就见到有人书写了一些交易的通用程序模板，在该模板中把一些网络通讯、数据库操作的、业务操作共性的东西写在一个文件中，在这些文件中用些诸如"@@@N、###N"奇怪字串标注一些位置，然后书写交易时，只需按照一种特定的规则书写特定的处理，最后在 make 时，使用 awk 和sed，把模板中的"@@@N、###N"等字串替代成特定的程序，形成 C 文件，然后再编译。这个动作很像数据库的"扩展 C"语言(即在 C 语言中用"EXEC SQL"的样子执行 SQL 语句，在用cc/gcc 编译之前，需要使用"扩展 C"的翻译程序，如 cpre，把其翻译成标准 C)。如果你在使用 make 时有一些更为绝妙的方法，请记得告诉我啊。
</p>
<p>
  回头看看整篇文档，不觉记起几年前刚刚开始在 Unix 下做开发的时候，有人问我会不会写 Makefile 时，我两眼发直，根本不知道在说什么。一开始看到别人在 vi 中写完程序后输入"!make"时，还以为是 vi 的功能，后来才知道有一个 Makefile 在作怪，于是上网查啊查，那时又不愿意看英文，发现就根本没有中文的文档介绍 Makefile，只得看别人写的Makefile，自己瞎碰瞎搞才积累了一点知识，但在很多地方完全是知其然不知所以然。后来开始从事 UNIX 下产品软件的开发，看到一个 400 人年，近 200 万行代码的大工程，发现要编译这样一个庞然大物，如果没有 Makefile，那会是多么恐怖的一样事啊。于是横下心来，狠命地读了一堆英文文档，才觉得对其掌握了。但发现目前网上对 Makefile 介绍的文章还是少得那么的可怜，所以想写这样一篇文章，共享给大家，希望能对各位有所帮助。
</p>
<p>
  现在我终于写完了，看了看文件的创建时间，这篇技术文档也写了两个多月了。发现，自己知道是一回事，要写下来，跟别人讲述又是另外一回事，而且，现在越来越没有时间专研技术细节，所以在写作时，发现在阐述一些细节问题时很难做到严谨和精练，而且对先讲什么后讲什么不是很清楚，所以，还是参考了一些国外站点上的资料和题纲，以及一些技术书籍的语言风格，才得以完成。整篇文档的提纲是基于 GNU 的 Makefile 技术手册的提纲来书写的，并结合了自己的工作经验，以及自己的学习历程。因为从来没有写过这么长，这么细的文档，所以一定会有很多地方存在表达问题，语言歧义或是错误。因些，我迫切地得等待各位给我指证和建议，以及任何的反馈。
</p>
<p>
  最后，还是利用这个后序，介绍一下自己。我目前从事于所有Unix平台下的软件研发，主要是做分布式计算/网格计算方面的系统产品软件，并且我对于下一代的计算机革命——网格计算非常地感兴趣，对于分布式计算、P2P、Web Service、J2EE技术方向也很感兴趣，同时，对于项目实施、团队管理、项目管理也小有心得，希望同样和我战斗在“技术和管理并重”的阵线上的年轻一代，能够和我多多地交流。我的MSN是:<a href="#haoel-hotmail.com">haoel@hotmail.com</a>(常用)，QQ是:753640(不常用)。(注:请勿给我MSN的邮箱发信，由于hotmail的垃圾邮件导致我拒收这个邮箱的所有来信)
</p>
<p>
  我欢迎任何形式的交流，无论是讨论技术还是管理，或是其它海阔天空的东西。除了政治和娱乐新闻我不关心，其它只要积极向上的东西我都欢.
</p></div>
</div>
</div>

<div id="postamble">
<p class="date">Date: 2012-04-11 Wed</p>
<p class="author">Author: Joseph Pan</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>
